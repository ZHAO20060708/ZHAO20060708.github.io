[{"content":"呐\u0026hellip;\u0026hellip;不知道说什么好呢 这里是Eric Zhao，一个平平无奇的双学位大学生，目前就读于长春某985院校（长春好像就一个985），随缘更新编程、数学相关内容（以及商学与管理学）\n注意 文章中的应用和代码如果不另外说明均在\n平台上运行（基于archlinux）\nWant a site like this? Check out hugo-theme-stack-stater\nPhoto by Pawel Czerwinski on Unsplash\n","date":"2024-11-05T00:00:00Z","image":"https://zhao20060708.github.io/p/hello-world/cover_hu_e95a4276bf860a84.jpg","permalink":"https://zhao20060708.github.io/p/hello-world/","title":"Hello World"},{"content":"一、名词解释 物流：根据实际需要，将运输、储存、装卸、搬运、包装、流通加工、配送、信息处理等基本功能实施有机结合，使物品从供应地向接收地进行实体流动的过程。\n物流管理（国标）：为达到既定的目标，从物流全过程出发，对相关物流活动进行的计划、组织、协调与控制。\n物流管理（美国物流/供应链管理专业协会）：供应链管理的一部分，是对货物、服务及相关信息从起源地到消费地的有效率、有效益的正向和反向流动和储存进行的计划、执行和控制，以满足顾客要求（CLM 2003年定义）。\n第三方物流：由独立于物流服务供需双方之外且以物流服务为主营业务的组织提供物流服务的模式。\n国际物流（广义）：当生产和消费分别在两个或两个以上国家（地区）独立进行时，为了克服生产和消费之间的空间隔离和时间距离，对物资（商品）进行物理性移动的一项国际商品贸易或交流活动，从而完成国际商品交易的最终目的。\n冷链物流：根据物品特性，从生产到消费的过程中使物品始终处于保持其品质所需温度环境的物流技术与组织系统。\n运输：利用载运工具、设施设备及人力等运力资源，使货物在较大空间上产生位置移动的活动。\n仓储：利用仓库及相关设施设备进行物品的进库、储存、出库的作业。\n库存：储存作为今后按预定的目的使用而处于闲置或非生产状态的物品，广义还包括处于制造加工状态和运输状态的物品。\n配送：根据客户要求，对物品进行分类、拣选、集货、包装、组配等作业，并按时送达指定地点的物流活动。\n二、简答题 物流管理所创造的价值包括？\n空间价值（效用）：通过运输等环节克服物品供应地与接收地的空间障碍，让物品从产出地到达需求地，实现“物尽其用”，比如将南方的水果运到北方销售，就创造了空间价值； 时间价值（效用）：通过仓储等手段调节物品供需的时间差，使物品在需要的时候及时出现，例如粮食丰收后储存，在淡季供应，避免滞销或短缺； 部分形态价值（效用）：通过流通加工改变物品形态，满足客户特定需求，如将钢材切割成适配的零件尺寸、将生鲜食材预处理，提升物品使用价值。 物流（微观/宏观）的地位包括？\n微观（企业层面）：\n利润源泉：物流成本是企业可控的重要成本，优化物流可直接降低开支，提升利润； 成本中心：物流活动涉及运输、仓储等多环节开支，是企业成本管理的核心领域； 服务中心：物流服务质量（如配送时效、完好率）直接影响客户满意度，是企业服务能力的体现； 企业战略：高效物流能支撑企业市场扩张、差异化竞争，是战略布局的重要部分； 宏观（社会经济层面）：\n基础性：物流连接生产与消费，是社会经济运转的“血脉”，保障商品流通； 先导性：物流产业的发展能带动制造业、零售业等相关产业升级，引领经济发展方向； 战略性：国际物流、应急物流等关系国家经济安全和民生保障，是国家战略的重要组成。 物流系统流动性要素包括？\n流体：指物流的对象，即各类物品，是物流活动的核心载体； 载体：承载流体移动的工具和设施，如运输车辆、仓库、港口等； 流向：物品的流动方向，如从工厂到仓库、从仓库到门店的定向移动； 流量：一定时间内物品流动的数量，是规划物流能力的依据； 流程：物品从起点到终点的完整流动路径，涵盖各环节的衔接； 流速：物品流动的速度，直接影响物流时效和客户体验； 流效：物流流动的效率和效益，体现为成本控制、时效达标等综合效果。 物流系统内部结构的原理包括？\n物流要素集成化原理：将运输、仓储、信息等分散的物流要素整合，形成协同效应，避免各环节脱节，提升整体效率； 物流组织网络化原理：构建覆盖供需点的物流网络（如分拨中心、配送网点），通过网络节点的合理布局，实现物品高效流转； 物流接口无缝化原理：消除物流各环节（如运输与仓储、仓储与配送）的衔接障碍，实现信息、流程、设施的顺畅对接，减少等待和损耗。 物流作业目标（系统表述）\n服务目标：以客户需求为核心，保障配送及时、物品完好，提升客户满意度； 快速及时：缩短物流周期，加快物品流转速度，满足客户对时效的要求； 节约：通过优化路线、整合资源等方式，降低物流成本，提高经济效益； 规模优化目标：集中处理批量货物，发挥规模效应，降低单位物流成本； 库存调节：合理控制库存水平，既避免缺货影响供应，又防止库存积压占用资金。 物流作业目标（微观表述）\n快速响应：迅速响应客户订单，缩短订单处理和配送的时间间隔； 最小变差：减少物流过程中的不确定性，如避免配送延迟、物品损坏等问题； 最低库存：在保障供应的前提下，将库存降至最低，减少资金占用和仓储成本； 整合运输：将零散货物集中运输，选择最优运输方式组合，提高运输效率； 质量：确保物流各环节的作业质量，如包装牢固、分拣准确、配送完好； 生命周期支持：覆盖物品从生产到废弃的全周期物流服务，包括回收、逆向物流等。 国际物流的特点\n标准化：需遵循国际通用的物流标准（如集装箱尺寸、报关流程），确保跨国衔接顺畅； 复杂性：涉及不同国家的法律法规、语言文化、货币结算等，环节更多，协调难度大； 风险性：面临汇率波动、政治动荡、国际运输事故、海关政策变化等多种风险； 不规则性：受各国经济形势、季节需求、贸易壁垒等影响，物流流量和流向易发生变化。 物流标准化的意义和作用\n物流系统统一管理的要求：统一标准使各环节（如运输、仓储）操作规范一致，便于系统整体协调； 节约成本提高效益：标准化减少重复作业和资源浪费（如通用包装可循环使用），降低物流成本； 加快物流系统建设：依据标准快速搭建物流设施、配置设备，提升系统建设效率； 便于推行物流管理：标准化的流程和数据便于量化考核和精细化管理，提升管理水平； 创造与外部系统的联系条件：符合国际或行业标准，使物流系统能与上下游企业、国际物流网络对接。 按标准的性质分类物流标准可以划分为？\n物流技术标准：针对物流技术设备、操作工艺的标准，如运输车辆载重标准、仓储货架承重标准； 物流工作标准：规范物流作业流程和人员操作的标准，如快递分拣操作规范、配送员服务标准； 物流管理标准：用于物流管理活动的标准，如库存管理指标、物流成本核算标准； 物流基础标准：物流领域最基本的通用标准，如物流术语、计量单位、编码标准。 运输的基本原则包括？\n及时：按客户要求的时间将货物送达，避免延迟影响生产或销售； 安全：保障货物在运输过程中完好无损，防止丢失、损坏、变质等情况； 经济：在满足需求的前提下，选择成本最低的运输方式和路线，控制运输开支； 准确：确保货物的品种、数量、目的地等信息无误，精准送达指定地点。 运输的基本要素包括？\n基础设施：支撑运输的固定设施，如公路、铁路、港口、机场、货运站等； 运输设备：直接承载货物的工具，如卡车、火车、船舶、飞机、集装箱等； 运输参与主体：参与运输活动的各方，如货主、承运人、货运代理、装卸工人等； 运输路线：货物从起点到终点的具体路径，需结合距离、路况、成本等选择； 运输节点：运输路线上的关键衔接点，如分拨中心、中转站，用于货物装卸、中转。 五大运输方式包括？\n公路运输：以汽车为主要工具，灵活便捷，适合短途或门到门运输； 铁路运输：以火车为工具，载重量大、成本低，适合大宗货物长途运输； 水运：以船舶为工具，分为内河运输和海运，成本最低，适合超大批量、长距离货物； 航空运输：以飞机为工具，速度最快，成本高，适合紧急、高价值或轻小件货物； 管道运输：以管道为工具，主要运输石油、天然气等流体货物，连续稳定、损耗小。 合理运输的组成要素包括？\n运输距离：缩短运输距离可减少运费和时间，是合理运输的首要因素； 运输环节：减少不必要的装卸、中转环节，降低货物损耗和成本； 运输工具：根据货物特性（如重量、时效）选择适配的运输工具，发挥工具优势； 运输时间：在保障安全的前提下缩短运输时间，提高物流效率； 运输费用：综合平衡各要素，实现运输费用最低，提升经济效益。 提高运输工具实载率的方法包括？\n组织轻重配装：将轻型货物与重型货物搭配装载，充分利用运输工具的载重和容积空间，避免单一货物造成的空间或载重浪费； 实行解体运输：对大型、 bulky 货物（如机械设备）进行拆分装载，使其适配运输工具尺寸，提高装载效率； 改进堆码方法：采用科学的堆码方式（如分层交错堆码、立体堆码），减少货物间的空隙，最大化利用车厢容积。 不合理储存的现象包括？\n储存时间过长：货物储存超过需求周期，导致变质、贬值，增加仓储成本； 储存数量过大：库存远超实际需求，占用大量资金和仓储空间，造成资源浪费； 储存数量过低：库存不足无法满足突发需求，导致缺货，影响客户信任； 储存条件不足或过剩：条件不足（如温湿度不达标）导致货物损坏，条件过剩（如普通货物用恒温库）增加成本； 储存结构失衡：各类货物库存比例失调，有的积压、有的短缺，无法匹配需求结构。 自动化立体库的构成包括？\n立体货架：高层货架结构，用于密集存放货物，最大化利用仓库空间； 巷道式堆垛起重机（穿梭车+升降机）：核心搬运设备，沿货架巷道移动，通过穿梭车取放货物，升降机实现不同层高的作业； 输送系统：连接立体货架与仓库出入口的设备，如传送带、AGV，负责货物的进出库输送； 控制系统：由计算机系统、传感器等组成，实现对堆垛机、输送系统的自动化调度和监控，保障作业精准高效。 库存的重要性\n提高客户服务水平：提前储备货物，能快速响应客户订单，避免缺货流失客户； 调节季节差异：应对季节性生产或需求（如农产品丰收、节日促销），平衡供需； 实现经济规模：批量采购或生产可获得价格优惠，通过库存消化批量货物，降低单位成本； 节约企业成本：避免因紧急采购产生的高价费用，减少生产中断的损失； 满足客观要求：应对供应链中的不确定性（如运输延迟、原料短缺），保障生产经营连续。 库存的弊端\n占用大量资金：库存货物占用企业流动资金，影响资金周转效率，增加融资成本； 发生库存成本：包括仓储费、管理费、保险费、货物损耗费等，直接增加企业开支； 引发管理问题：库存过多易导致货物积压、变质、盘点困难，增加管理难度，还可能掩盖生产或销售中的问题（如产品滞销）。 库存成本构成\n库存持有成本：为维持库存而发生的成本，包括仓储费、资金利息、保险费、损耗费等； 订货或生产准备成本（获得成本）：为获取货物发生的成本，如订货手续费、采购差旅费、生产设备调试费等； 缺货成本：因库存不足无法满足需求而产生的成本，如缺货导致的订单流失、客户索赔、生产中断损失等。 库存持有成本的构成包括？\n空间成本：用于储存货物的场地费用，如仓库租金、场地维护费； 资金成本：库存货物占用资金的机会成本，即资金用于其他投资的潜在收益； 库存服务成本：为库存提供服务的费用，如保险费、盘点费、安保费； 库存风险成本：因库存管理不当产生的损失，如货物变质、过期、破损、被盗等费用。 库存控制主要考虑什么？\n库存资金控制：将库存占用的资金控制在合理范围，避免资金积压，通过优化订货批量、减少滞销库存实现； 库存风险控制：降低库存损耗、变质、过期等风险，通过合理规划储存条件、先进先出管理、定期盘点实现； 库存结构控制：确保各类货物库存比例适配需求，避免部分货物积压、部分货物缺货，通过需求预测和动态调整实现。 配送的意义和作用\n完善输送及物流系统：弥补干线运输（如铁路、海运）“门到门”能力不足的问题，实现物流末端闭环； 提高末端物流经济效益：集中配送零散订单，减少重复运输，降低末端运输成本； 实现企业低库存或零库存：通过第三方配送或集中配送，企业无需大量储备货物，释放仓储空间和资金； 简化手续方便用户：用户无需自行提货，只需下单即可享受上门服务，减少采购环节的人力物力消耗； 提高供应保证程度：专业配送系统响应快、调度灵活，能及时满足用户的紧急需求，保障供应稳定。 提高配送经济效益的途径？\n恰当设置配送中心：在区域中心位置选址，覆盖范围广、交通便利，减少配送半径和运输成本； 加强配送计划性：提前整合订单，规划最优配送路线，避免重复派单和空驶，提高车辆利用率； 实行共同配送：多个企业联合开展配送，共享车辆、仓储等资源，发挥规模效应，降低单位配送成本； 加强信息系统建设：通过物流信息系统实现订单处理、路线规划、货物跟踪的自动化，提高配送效率，减少人工差错。 包装的功能\n保护功能：核心功能，防止货物在运输、储存中受冲击、挤压、潮湿、污染等损坏，如易碎品的缓冲包装、食品的密封包装； 便利功能：方便货物的装卸、搬运、储存和计数，如标准化纸箱便于堆叠，带提手的包装便于携带； 促销功能：通过包装设计（如图案、色彩、品牌标识）吸引消费者注意，传递产品信息，提升购买意愿。 包装设计的要求\n方便性：便于开启、使用、携带和回收，如拉链式包装袋、可折叠的包装； 简量化：在保障功能的前提下，减少包装材料消耗，避免过度包装，降低成本和环保压力； 结构牢固：包装结构能承受物流过程中的外力，防止破损，如重型货物的瓦楞纸箱需加厚设计； 标准化：采用通用的尺寸、材质标准，便于堆叠、运输和回收，提高物流效率。 包装合理化途径\n轻薄化：采用轻质、高强度的包装材料（如新型塑料、复合纸），减少包装重量和体积； 单纯化：简化包装结构和材质，避免多种材料混合导致回收困难，如单一纸质包装； 标准化：推行统一的包装尺寸和规格，适配运输工具和仓储设施，提高装载效率； 机械化：采用包装机械（如自动封箱机、缠绕机）提高包装效率和质量，减少人工成本； 绿色化：使用可降解、可回收的环保材料，减少包装废弃物对环境的污染。 装卸搬运的作用\n物流各阶段转换的桥梁：连接运输、仓储、配送等环节，如货物到港后通过装卸搬运进入仓库，仓库货物通过装卸搬运装上配送车辆； 连接不同运输方式，保障多式联运：在铁路、公路、水运的衔接点（如港口、货运站），通过装卸搬运实现货物在不同运输工具间的转换，支撑多式联运开展； 生产与流通领域的重要组成部分和保障系统：生产中原材料、半成品的搬运保障生产连续，流通中装卸搬运保障商品顺利流转，是物流和生产的基础支撑。 装卸搬运的原则\n有效作业原则：只进行必要的装卸搬运，避免重复作业，如直接将货物从货车卸到配送车上，减少中间环节； 集中作业原则：将货物集中在一个区域作业，便于设备调度和人员配合，提高作业效率； 简化流程原则：优化装卸搬运流程，减少货物的翻转、移动次数，降低损耗和成本； 安全作业原则：规范操作流程，配备安全防护设备，避免人员受伤和货物损坏； 系统优化原则：将装卸搬运融入整个物流系统，与运输、仓储等环节协同，提升整体物流效率。 防止无效装卸的措施\n减少装卸次数：通过优化物流流程，实现“门到门”运输，避免货物在多个节点反复装卸，如工厂直接送货到门店； 消除多余包装：去除不必要的包装层次（如过度的缓冲材料），减少装卸搬运的重量和体积，同时降低成本； 去除无效物质：在装卸前清理货物中的杂质、废弃物（如包装内的填充物、货物附带的无用部件），减少无效搬运量。 物流信息的特点（左侧五点）\n广泛性：物流信息覆盖运输、仓储、配送等全环节，涉及货主、承运人、客户等多方主体，来源和内容丰富； 联系性：各环节的物流信息相互关联，如订单信息影响配送信息，配送信息关联库存信息，形成完整的信息链； 多样性：信息形式多样，包括文字（订单）、数据（库存数量）、图像（货物照片）、语音（调度指令）等； 动态性：物流活动实时变化，如货物位置、库存数量、运输状态等信息随时间不断更新，需及时捕捉； 复杂性：信息量大且来源分散，不同主体的信息格式、标准可能不同，整合和处理难度较大。 （注：文档由 AI 生成）\n","date":"2025-12-18T00:00:00Z","permalink":"https://zhao20060708.github.io/p/%E7%89%A9%E6%B5%81%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A%E5%8F%8A%E7%AE%80%E7%AD%94%E9%A2%98%E8%A7%A3%E7%AD%94/","title":"物流术语解释及简答题解答"},{"content":" 第一优先级：括号运算符（()）和数组下标运算符（[]）以及成员访问运算符（.和-\u0026gt;） 括号运算符用于改变运算顺序。例如(a + b)*c，先计算括号内的a + b。 数组下标运算符用于访问数组元素，如a[3]。 成员访问运算符用于访问结构体或联合体中的成员，如struct student s; s.age（通过对象访问）或者struct student *p; p-\u0026gt;age（通过指针访问）。 第二优先级：一元运算符（如++、\u0026ndash;、!、~、-、+、*、\u0026amp;） 自增（++）和自减（--）运算符有前置和后置之分。前置是先改变变量的值再使用，后置是先使用变量的值再改变。例如int a = 1; int b=++a;（b的值为2，a的值为2），int c = 1; int d = c++;（d的值为1，c的值为2）。 !是逻辑非运算符，将真变为假，假变为真。例如int a = 0; int b=!a;（b的值为1）。 ~是按位取反运算符，对一个整数的二进制位进行取反操作。 -和+在这里作为一元运算符时，分别表示取负和取正。例如int a=-3;（取负），int b = +4;（取正，通常可以省略+）。 *作为一元运算符是指针运算符，用于访问指针所指向的内容。例如int a = 10; int *p=\u0026amp;a; int b=*p;（b的值为10）。 \u0026amp;是取地址运算符，用于获取变量的地址。例如int a; int *p = \u0026amp;a;获取a的地址并赋值给p。 第三优先级：算术运算符（乘除模：*、/、%） 乘法、除法和取模运算优先级相同。例如int a = 6/2*3;（先计算6/2得到3，再乘以3，结果为9），int b = 7%3;（结果为1）。 第四优先级：算术运算符（加减：+、-） 加法和减法优先级相同。例如int a = 3 + 4-2;（先计算3 + 4得到7，再减去2，结果为5）。 第五优先级：移位运算符（左移：\u0026laquo;，右移：\u0026raquo;） 左移运算符\u0026lt;\u0026lt;是将一个数的二进制位向左移动指定的位数，右边补0。例如int a = 1\u0026lt;\u0026lt;3;（1的二进制是00000001，左移3位后得到00001000，即8）。 右移运算符\u0026gt;\u0026gt;是将一个数的二进制位向右移动指定的位数。如果是无符号数，左边补0；如果是有符号数，左边补符号位。例如unsigned int b = 8\u0026gt;\u0026gt;2;（8的二进制是00001000，右移2位后得到00000010，即2）。 第六优先级：关系运算符（\u0026lt;、\u0026lt;=、\u0026gt;、\u0026gt;=） 用于比较两个值的大小关系。例如int a = 3; int b = 5; int c=a \u0026lt; b;（c的值为1，因为3小于5）。 第七优先级：关系运算符（==、!=） 用于判断两个值是否相等或不相等。例如int a = 3; int b = 3; int c=a == b;（c的值为1）。 第八优先级：逻辑与运算符（\u0026amp;\u0026amp;） 只有当两个操作数都为真时，结果才为真。例如int a = 1; int b = 0; int c=a \u0026amp;\u0026amp; b;（c的值为0）。 第九优先级：逻辑或运算符（||） 只要两个操作数中有一个为真，结果就为真。例如int a = 1; int b = 0; int c=a || b;（c的值为1）。 第十优先级：条件运算符（?:） 这是一个三目运算符，语法为表达式1?表达式2:表达式3。如果表达式1为真，则返回表达式2的值，否则返回表达式3的值。例如int a = 3; int b = 5; int c=(a \u0026gt; b)?a:b;（c的值为5）。 第十一优先级：赋值运算符（=、+=、-=、*=、/=、%=、\u0026laquo;=、\u0026raquo;=、\u0026amp;=、^=、|=） 基本的赋值运算符=用于将一个值赋给一个变量。例如int a; a = 3;。 复合赋值运算符是先进行算术或位运算，然后再赋值。例如int a = 3; a += 2;（相当于a = a+2，结果为5）。 第十二优先级：逗号运算符（,） 逗号运算符用于将多个表达式连接起来，从左到右依次计算表达式的值，整个逗号表达式的值等于最后一个表达式的值。例如int a = (3, 4, 5);（a的值为5）。 下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。\n类别 运算符 结合性 后缀 () [] -\u0026gt; . ++ -- 从左到右 一元 + - ! ~ ++ -- (type)* \u0026amp; sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 \u0026lt;\u0026lt; \u0026gt;\u0026gt; 从左到右 关系 \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= 从左到右 相等 == != 从左到右 位与 AND \u0026amp; 从左到右 位异或 XOR ^ 从左到右 位或 OR | 从左到右 逻辑与 AND \u0026amp;\u0026amp; 从左到右 逻辑或 OR || 从左到右 条件 ?: 从右到左 赋值 = += -= *= /= %= \u0026gt;\u0026gt;= \u0026lt;\u0026lt;= \u0026amp;= ^= |= 从右到左 逗号 , 从左到右 ","date":"2024-11-19T00:00:00Z","permalink":"https://zhao20060708.github.io/p/c%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8/","title":"C语言运算符优先级表"},{"content":"例2 设$ \\bm{X={1,2,\u0026hellip;,n,\u0026hellip;},Y={1,3,\u0026hellip;..2n-1,\u0026hellip;}} $, 对于任何一个$ \\bm{n\\in X} $ ,按照对应法则$ \\bm{f} $得到$ \\bm{2n-1\\in Y} $,则映射$ \\bm{f{:}X{\\to}Y} $是一一映射. 值得注意的是：$ \\bm{Y} $是$ \\bm{X} $ 的子集，$ \\bm{Y} $中的元素似乎比$ \\bm{X} $中的元素个数“少”,但实际是，在无限集合中，“部分可以等于整体”,这是无限集合的一个特性.$ \\bm{\\blacksquare} $ 并非所有的函数都有反函数,如$ y=f(x)=x^2 $, 定义域为$ D_f=(-∞,+∞) $\n, 值域为$ R_f=[0,+∞) $,显然$ f $不是一一映射,所以该函数没有反函数.\n但如果函数$ y=f(x) $是单调函数,则相应的映射必为一一映射,而相应的反函数必存在,故有如下结论：\n反函数存在定理:单调函数$ f $必存在单调的反函数,且此反函数与$ f $具有相同的单调性。\n注意: 不是任何两个的数都可以复合成一个复合函数的;\n例如，$ y = \\arcsin u，u=2+x^2；y≠\\arcsin(2+x^2) $ 复合函数可以由两个以上的函数经过复合构成。\n例如，$ y = \\sqrt{\\cot \\frac x2}，y=\\sqrt{u}，u=\\cot v，v=\\frac x2 $. 例9 判断函数 $ \\bm{f(x)=\\log_2\\left(x+\\sqrt{1+x^2}\\right)} $的奇偶性. 解: 函数$ f(x) $的定义域为$ (-\\infty,+\\infty). $对$ \\forall x $,由于\n$ f(-x)=\\log_{2}(-x+\\sqrt{1+\\left(-x\\right)^{2}})=\\log_{2}(\\sqrt{1+x^{2}}-x)\\\\=\\log_{2}\\frac{1}{\\sqrt{1+x^{2}}+x}=-\\log_{2}(x+\\sqrt{1+x^{2}})=-f(x), $\n所以函数$ f(x)=\\log_2(x+\\sqrt{1+x^2}) $是奇函数\n思考题1 已知$ \\bm{f(x)} $是一个偶函数，且满足$ \\bm{f(a+x)=f(a-x),} $则$ \\bm{f(x)} $是不是一个周期函数？若是，则说明它的一个周期，若不是，请说明理由 思考题解答 由$ f(a+x)=f(a-x) $可知：\n$ f(2a+x)=f[a+(a+x)]=f[a-(a+x)]=f\\left(-x\\right) $\n又因为$ f(x) $是一个偶函数， 所以$ f(2a+x)=f(x) $\n例1 求函数$ \\bm{y=\\sqrt{e^x+1}} $的反函数 解： $ \\because e^x=y^2-1 $\n$ \\therefore x=\\ln(y^2-1)\\quad y=\\sqrt{e^x+1}\\gt1 $，即原函数的值域为$ (1,+\\infty) $\n$ \\therefore $反函数为$ y=\\ln(x^2-1) $\n$ \\boldsymbol{D}_{f^{-1}}=(1,+\\infty) $\n例2 设$ \\bm{f(\\sin x)=\\cos2x+1} $,求$ \\bm{f(x)} $及$ \\bm{f(\\cos x).} $ 解： 因为$ f(\\sin x)=\\cos2x+1=1-2\\sin^2x+1=2-2\\sin^2x, $\n所以$ f\\left(x\\right)=2-2x^{2},\\quad f(\\cos x)=2-2\\cos^2x=2\\sin^2x. $\n例4 设函数 $ \\bm{f(x)} $的定义域为$ \\bm{(-l,l)} $, 证明必定存在$ \\bm{(-l,l)} $上的偶函数$ \\bm{g(x)} $及奇函数$ \\bm{h(x)} $,使得$ \\bm{f(x)=g(x)+h(x).} $ 分析 如果这样的$ g(x) $和$ h(x) $存在，于是\n$ \\begin{cases}f(x)=g(x)+h(x)\\\\f(-x)=g(-x)+h(-x)=g(x)-h(x)\\end{cases} $\n证明 设\n$ \\begin{cases}g(x)=\\frac12[f(x)+f(-x)]\\\\h(x)=\\frac12[f(x)-f(-x)]\\end{cases} $\n显然$ f\\left(x\\right)=g\\left(x\\right)+h\\left(x\\right). $\n$ g\\left(-x\\right)=\\frac12|f\\left(-x\\right)+f\\left(x\\right)|=|f\\left(x\\right) $是偶函数，\n$ -h(x)=\\frac12[f(-x)-f(x)]=h(-x) $是奇函数.\n已知 $ f(\\tan x)=\\sec^2x+1 $,求 $ f(x). $\n解：\n$ f(\\tan x)=\\left(\\tan^2x+1\\right)+1 $\n$ \\therefore f\\left(x\\right)=\\left(x^{2}+1\\right)+1=x^{2}+2 $\n思考题 分段函数一定不是初等函数吗？ 解答 不一定\n$y=\\begin{cases}x\u0026amp;x\\geq0\\\\-x\u0026amp;x\u0026lt;0\\end{cases}$\n它是一个分段函数， 但是，$ y=\\left|x\\right|=\\sqrt{x^{2}} $ 根据定义，它是一个初等函数。\n$ \\sin x+\\sin y=2\\sin\\frac{x+y}2\\cos\\frac{x-y}2 $\n$ \\sin x-\\sin y=2\\cos\\frac{x+y}2\\sin\\frac{x-y}2 $\n$ \\cos x+\\cos y=2\\cos\\frac{x+y}{2}\\cos\\frac{x-y}{2} $\n$ \\cos x-\\cos y=-2\\sin\\frac{x+y}{2}\\sin\\frac{x-y}{2} $\n$ \\sin x\\sin y=-\\frac{1}{2}[\\cos(x+y)-\\cos(x-y)] $\n$ \\cos x\\cos y=\\frac12[\\cos(x+y)+\\cos(x-y)] $\n$ \\sin x\\cos y=\\frac{1}{2}[\\sin(x+y)+\\sin(x-y)] $\n$ \\sin x=\\cos(x-\\frac{\\pi}{2}) $\n$ \\cos x=\\sin(x+\\frac{\\pi}{2}) $\n$ \\cos^{2}x-\\sin^{2}x=\\cos2x $\n$ \\sin^{2}x+\\cos^{2}x=1 $\n$ \\tan^{2}x+1=\\sec^{2}x $\n$ \\sin 2x=2\\sin x\\cos x $\n$ \\cot^{2}x+1=\\csc^{2}x $\n$ \\sin(x\\pm y)=\\sin x\\cos y\\pm\\cos x\\sin y $\n$ \\cos\\left(x\\pm y\\right)=\\cos x\\cos y\\mp\\sin x\\sin y $\n$ \\sin x+\\sin y=2\\sin\\frac{x+y}{2}\\cos\\frac{x-y}{2} $\n注意:数列极限的定义未给出求极限的方法。\n例1：证明$ \\bm{\\lim_{n\\to\\infty}\\frac{n+(-1)^{n-1}}n=1.} $ 证：\n$ |x_n-1|=\\left|\\frac{n+(-1)^{n-1}}n-1\\right|=\\frac1n $\n任给$ \\varepsilon\\gt0 $，要$ |x_n-1|\\lt\\varepsilon $,只要$ \\frac1n\\lt\\varepsilon, $或$ n\\gt\\frac1\\varepsilon $，\n给定$ \\frac1{100} $, 由$ \\frac1n\u0026lt;\\frac1{100} $,只要 $ n\u0026gt;100 $时，有$ |x_n-1|\u0026lt;\\frac1{100} $,\n给定$ \\frac1{1000} $,只要 $ n\u0026gt;1000 $ 时，有$ |x_n-1|\u0026lt;\\frac1{1000} $,\n给定$ \\frac1{10000} $,只要$ n\u0026gt;10000 $时，有$ |x_n-1|\u0026lt;\\frac1{10000} $,\n给定 $ \\varepsilon \u0026gt; 0 $, 只要 $ n\u0026gt;N(=\\begin{bmatrix} \\frac1\\varepsilon\\end{bmatrix}) $时，有$ |x_n-1|\u0026lt;\\varepsilon $成立.\n例2 设$ \\bm{x_n\\equiv C} $（$ \\bm{C} $为常数），证明$ \\bm{\\lim_{n\\to\\infty} x_n=C.} $ 证：\n任给$ \\varepsilon\u0026gt;0 $,对于一切正整数$ n $,\n$ |x_n-C|=|C-C|=0\u0026lt;\\varepsilon $成立，\n所以，$ \\lim_{n\\to\\infty} x_n=C. $\n说明：常数列的极限等于同一常数。\n小结：用定义证明数列极限存在时，关键是任意给定$ \\bm{\\varepsilon\u0026gt;0} $,寻找$ \\bm{N} $,但不必要求最小的$ \\bm{N} $.\n例3：设$ \\bm{|q|\u0026lt;1} $,证明等比数列$ \\bm{\\lim_{n\\to\\infty}q^n=0} $. 证：\nq=0时，等式显然成立。当$ 0\u0026lt;|q|\u0026lt;1 $,$ |x_n-0|=|q^n-0|=|q|^n $\n$ \\forall\\varepsilon\\in(0,1) $，要使$ \\left|x_n-0\\right|\u0026lt;\\varepsilon $，只要$ \\left|q\\right|^n\u0026lt;\\varepsilon $，\n即\n$ n\\ln | q| \u0026lt; \\ln \\varepsilon $,亦即$ n\u0026gt; \\frac {\\ln \\varepsilon }{\\ln | q| }. $\n因此，取 $ N= \\begin{bmatrix} \\frac {\\ln \\varepsilon }{\\ln | q| }\\end{bmatrix} $，则当$ n\u0026gt; N $时，就有$ |q^n-0|\u0026lt;\\varepsilon $,故$ \\lim_{n\\to\\infty}q^n=0 $.\n例4 证明数列 $ \\bm{x_n=(-1)^{n+1}} $是发散的 . 证：\n设$ \\lim_n\\to\\infty x_n=a $, 由定义，对于$ \\varepsilon=\\frac12 $,则$ \\exists N $,使得当$ n\u0026gt;N $时，有$ |x_n-a|\u0026lt;\\frac12 $成立，\n即当$ n\u0026gt;N $时$ , x_n\\in ( a- \\frac 12, a+ \\frac 12) $, 区间长度为1.\n而$ x_n $无休止地反复取1，-1两个数，不可能同时位于长度为1的区间内.\n事实上，$ {x_n} $是有界的 ,但却发散.\n$ (a+b) (a²-ab+b²)=a³+b³ $\n根据极限定义证明：函数$ f(x) $当$ x $趋近于$ x_0 $时 极限存在的充分必要条件是左极限、右极限各自存在并且相等 为了证明这个定理，我们需要分别从充分性和必要性两个 方面进行证明。\n充分性 假设函数 $ f(x) $ 在点 $ x_0 $ 处的左极限和右极限都存在且相等，即：\n$ \\lim_{x \\to x_0^-} f(x) = L \\quad \\text{和} \\quad \\lim_{x \\to x_0^+} f(x) = L $\n我们需要证明函数 $ f(x) $ 在点 $ x_0 $ 处的极限存在并且等于 $ L $。\n根据极限的定义，对于任意给定的小正数$ \\epsilon \u0026gt; 0 $，存在一个delta \u0026gt; 0，使得当$ 0 \u0026lt; |x - x_0| \u0026lt; \\delta $ 时，有：\n$ |f(x) - L| \u0026lt; \\epsilon $\n这个 delta 可以同时适用于左极限和右极限的定义。因为无论 $ x $ 是从左边还是右边接近$ x_0 $，只要 $ x $ 距离 $ x_0 $ 的距离小于$ \\delta $，$ f(x) $ 都会靠近 $ L $ 并且与 $ L $的差小于 $ \\epsilon $。\n因此，当 $ x $ 趋近于 $ x_0 $ 时，无论从left 或 right，$ f(x) $ 的极限都是 $ L $。所以，函数 $ f(x) $ 在点 $ x_0 $ 处的极限存在并且等于 $ L $。\n必要性 假设函数 $ f(x) $ 在点 $ x_0 $ 处的极限存在，记为\n$ L $，即：\n$ \\lim_{x \\to x_0} f(x) = L $\n我们需要证明函数 $ f(x) $ 在点 $ x_0 $ 处的左极限和右极限都存在并且相等。\n由于 $ f(x) $ 的极限在 $ x_0 $ 存在，对于任意给定的小正数 $ \\epsilon \u0026gt; 0 $，存在一个delta \u0026gt; 0，使得当$ 0 \u0026lt; |x - x_0| \u0026lt; \\delta $ 时，有：\n$ |f(x) - L| \u0026lt; \\epsilon $\n现在我们来分别考虑左极限和右极限。\n左极限：对于任意 $ \\epsilon \u0026gt; 0 $，存在\n$ \\delta^- \u0026gt; 0 $ 使得当 $ 0 \u0026lt; x_0 - x \u0026lt; \\delta^- $ 时，有： $$|f(x) - L| \u003c \\epsilon$$这说明当 $ x $ 从左边接近 $ x_0 $ 时，$ f(x) $ 趋近于$ L $。\n右极限：对于任意 $ \\epsilon \u0026gt; 0 $，存在$ \\delta^+ \u0026gt; 0 $ 使得当 $ 0 \u0026lt; x - x_0 \u0026lt;\\delta^+ $ 时，有： $$|f(x) - L| \u003c \\epsilon$$这说明当 $ x $ 从右边接近 $ x_0 $ 时，$ f(x) $ 趋近于$ L $。\n由于上述两个条件对于任意的 $ \\epsilon \u0026gt; 0 $ 都可以找到对应的 $ \\delta^- \u0026gt; 0 $ 和 $ \\delta^+ \u0026gt; 0 $，这意味着：\n$ \\lim_{x \\to x_0^-} f(x) = L \\quad \\text{和} \\quad \\lim_{x \\to x_0^+} f(x) = L $\n因此，函数 $ f(x) $ 在点 $ x_0 $ 处的左极限和右极限都存在并且相等。\n结论 综上所述，我们证明了：\n如果函数 $ f(x) $ 在点 $ x_0 $ 处的左极限和右极限都存在且相等，那么函数 $ f(x) $ 在点 $ x_0 $ 处的极限存在，并且等于这两个极限的共同值。 反之，如果函数 $ f(x) $ 在点 $ x_0 $ 处的极限存在，那么它的左极限和右极限也一定存在并且相等。 所以，函数 $ f(x) $ 在点 $ x_0 $ 处的极限存在的充分必要条件是其左极限和右极限都存在且相等。\n根据复合函数求导法则， $ \\frac{d}{dx} f(u) = f^\\prime(u) \\cdot u^\\prime $\n当 $ x \\to 0 $ 时，\n$ x \\sim \\sin x \\sim \\tan x \\sim \\arcsin x \\sim \\arctan x \\sim \\ln(1 + x) \\sim e^x - 1 $;\n$ 1 - \\cos x \\sim \\frac{x^2}{2} $;\n$ (1 + x)^a - 1 \\sim ax\\ (a \\neq 0) $;\n$ a^x - 1 \\sim x \\ln a(a \u0026gt; 0, a \\neq 1) $.\n基本初等函数的求导公式 (1) $ (C)'= 0 $$ (C为常数)\n(2) $(x\\mu)\u0026rsquo; = \\mu x{\\mu - 1}$\n(3) $(\\sin x)\u0026rsquo; = \\cos x$\n(4) $(\\cos x)\u0026rsquo; = - \\sin x$\n(5) $(\\tan x)\u0026rsquo; = \\sec^2 x$\n(6) $(\\cot x)\u0026rsquo; = - \\csc^2 x$\n(7) $(\\sec x)\u0026rsquo; = \\sec x \\tan x$\n(8) $(\\csc x)\u0026rsquo; = - \\csc x \\cot x$\n(9) $(ax)\u0026rsquo; = ax \\ln a$\n(10) $(ex)\u0026rsquo; = ex$\n(11) $(\\log_a x)\u0026rsquo; = \\frac{1}{x \\ln a}$\n(12) $(\\ln x)\u0026rsquo; = \\frac{1}{x}$\n(13) $(\\arcsin x)\u0026rsquo; = \\frac{1}{\\sqrt{1 - x^2}}$\n(14) $(\\arccos x)\u0026rsquo; = \\frac{-1}{\\sqrt{1 - x^2}}$\n(15) $(\\arctan x)\u0026rsquo; = \\frac{1}{1 + x^2}$\n(16) $(\\text{arccot } x)\u0026rsquo; = \\frac{-1}{1 + x^2}$\n基本初等函数的微分公式 (1) $ \\mathrm{d}C = 0 $ (c为常数)\n(2) $ \\mathrm{d}x^\\mu = \\mu x^{\\mu - 1} \\mathrm{d}x $\n(3) $ \\mathrm{d} \\sin x = \\cos x \\mathrm{d}x $\n(4) $ \\mathrm{d} \\cos x = - \\sin x \\mathrm{d}x $\n(5) $ \\mathrm{d} \\tan x = \\sec^2 x \\mathrm{d}x $\n(6) $ \\mathrm{d} \\cot x = - \\csc^2 x \\mathrm{d}x $\n(7) $ \\mathrm{d} \\sec x = \\sec x \\tan x \\mathrm{d}x $\n(8) $ \\mathrm{d} \\csc x = - \\csc x \\cot x \\mathrm{d}x $\n(9) $ \\mathrm{d}a^x = a^x \\ln a \\mathrm{d}x $\n(10) $ \\mathrm{d}e^x = e^x \\mathrm{d}x $\n(11) $ \\mathrm{d} \\log_a x = \\frac{1}{x \\ln a} \\mathrm{d}x $\n(12) $ \\mathrm{d} \\ln x = \\frac{1}{x} \\mathrm{d}x $\n(13) $\\mathrm{d} \\arcsin x = \\frac{1}{\\sqrt{1 - x^2}} \\mathrm{d}x$\n(14) $\\mathrm{d} \\arccos x = \\frac{-1}{\\sqrt{1 - x^2}} \\mathrm{d}x$\n(15) $\\mathrm{d} \\arctan x = \\frac{1}{1 + x^2} \\mathrm{d}x$\n(16) $\\mathrm{d} \\text{ arccot } x = \\frac{-1}{1 + x^2} \\mathrm{d}x$\n一些需要注意的点 存在原函数的偶函数其原函数不一定是奇函数。只有当原函数中的常数项为 0 时，原函数才是奇函数。 收敛数列的性质 收敛数列极限唯一 收敛数列必有界 推论 无界数列必发散（2.的逆否命题） 有界数列未必收敛 保号性 若$x_n→a,y_n→b$，则$\\exists N \\in \\bold{N^+}$，当$n \u0026gt; N$ 时，有$x_n\u0026gt;y_n$. 若$x_n→a$，且$a \u0026lt; 0(a \u0026gt; 0)$，则$\\exists N \\in \\bold{N^+}$，当$n \u0026gt; N$ 时，有$x_n\u0026lt;0(x_n\u0026gt;0)$. 推论： $x_n→a,y_n→b$，若$x_n \\geq y_n$，则$a\\geq b$. $x_n→a,y_n→b$，若$x_n \\geq y_n$，则$a\\geq b$. 麦克劳林级数 几何级数 $\\frac{1}{1 - x} = \\sum_{n=0}^{\\infty} x^n = 1 + x + x^2 + x^3 + \u0026hellip; + x^n + \u0026hellip; \\qquad \\forall x:|x| \u0026lt; 1$\n二项式级数 $\\sum_{n=0}^{\\infty} \\binom{n}{k} x^n = (1 + x)^k=1 + kx + \\frac{k(k-1)}{2!}x^2 + \\frac{k(k-1)(k-2)}{3!}x^3 + \u0026hellip; + \\frac{k(k-1)\u0026hellip;(k-n+1)}{n!}x^n + \u0026hellip; \\qquad \\forall x: |x| \u0026lt; 1, \\forall k: k \\in \\mathbb{C}$\n指数函数 $e^x = \\sum_{n=0}^{\\infty} \\frac{x^n}{n!} = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \u0026hellip; + \\frac{x^n}{n!} + \u0026hellip; \\qquad \\forall x$\n自然对数 $\\ln(1 - x) = \\sum_{n=1}^{\\infty} \\frac{x^n}{n} = -x + \\frac{x^2}{2} - \\frac{x^3}{3} + \u0026hellip; + (-1)^{n+1} \\frac{x^n}{n} + \u0026hellip; \\qquad \\forall x: |x| \u0026lt; 1$\n$\\ln(1 + x) = \\sum_{n=1}^{\\infty} \\frac{(-1)^{n+1}x^n}{n} = x - \\frac{x^2}{2} + \\frac{x^3}{3} - \u0026hellip; + (-1)^{n+1} \\frac{x^n}{n} + \u0026hellip; \\qquad \\forall x: |x| \u0026lt; 1$\n三角函数 $\\sin x = \\sum_{n = 0}^{\\infty} \\frac{(-1)^n x^{2n + 1}}{(2n + 1)!} = x - \\frac{x^3}{3!} + \\frac{x^5}{5!} - \\cdots \\quad \\forall x$\n$\\cos x = \\sum_{n = 0}^{\\infty} \\frac{(-1)^n x^{2n}}{(2n)!} = 1 - \\frac{x^2}{2!} + \\frac{x^4}{4!} - \\cdots \\quad \\forall x$\n$\\tan x = \\sum_{n = 1}^{\\infty} \\frac{B_{2n} (-4)^n (1 - 4^n)}{(2n)!} x^{2n - 1} = x + \\frac{2x^5}{15} + \\cdots \\quad \\forall x : |x| \u0026lt; \\frac{\\pi}{2}$\n$\\sec x = \\sum_{n = 0}^{\\infty} \\frac{(-1)^n E_{2n} x^{2n}}{(2n)!} = 1 + \\frac{x^2}{2} + \\frac{5x^4}{24} + \\cdots \\quad \\forall x : |x| \u0026lt; \\frac{\\pi}{2}$\n$\\arcsin x = \\sum_{n = 0}^{\\infty} \\frac{(2n)!}{4^n (n!)^2 (2n + 1)} x^{2n + 1} = x + \\frac{x^3}{6} + \\frac{3x^5}{40} + \\cdots \\quad \\forall x : |x| \\leq 1$\n$\\arccos x = \\frac{\\pi}{2} - \\arcsin x = \\frac{\\pi}{2} - \\sum_{n = 0}^{\\infty} \\frac{(2n)!}{4^n (n!)^2 (2n + 1)} x^{2n + 1} = \\frac{\\pi}{2} - x - \\frac{x^3}{6} - \\frac{3x^5}{40} + \\cdots \\quad \\forall x : |x| \\leq 1$\n$\\arctan x = \\sum_{n = 0}^{\\infty} \\frac{(-1)^n x^{2n + 1}}{2n + 1} = x - \\frac{x^3}{3} + \\frac{x^5}{5} - \\cdots \\quad \\forall x : |x| \\leq 1, x \\neq \\pm i$\n","date":"2024-11-05T00:00:00Z","permalink":"https://zhao20060708.github.io/p/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/","title":"数学笔记"},{"content":"C语言中如何表示阶乘 在C语言中，阶乘通常使用循环来实现。以下是一个使用for循环计算阶乘的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;stdio.h\u0026gt; long long factorial(int n) { long long result = 1; for (int i = 1; i \u0026lt;= n; i++) { result *= i; } return result; } int main() { int num; printf(\u0026#34;请输入一个正整数：\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;num); if (num \u0026lt; 0) { printf(\u0026#34;输入的数必须是正整数！\\n\u0026#34;); } else { long long fact = factorial(num); printf(\u0026#34;%d 的阶乘是 %lld\\n\u0026#34;, num, fact); } return 0; } 在这个示例中，factorial 函数接受一个整数参数 n，并使用一个for循环从1到 n 遍历，将每个数累乘到 result 变量中，最终返回 result 作为阶乘的结果。在 main 函数中，我们提示用户输入一个正整数，然后调用 factorial 函数计算并输出阶乘结果。如果输入的数不是正整数，程序会输出错误提示信息。\n多维数组是什么，详细解释一下，并告诉我如何用C语言实现 多维数组是指在编程中用于存储多个维度数据的数组。多维数组可以看作是嵌套的数组，每一维都包含一个子数组。常见的多维数组包括二维数组、三维数组等。\n多维数组的特点 维度：多维数组有多个维度，每个维度可以有不同的长度。 索引：访问多维数组中的元素需要使用多个索引，每个索引对应一个维度。 内存布局：多维数组在内存中是连续存储的，但索引的方式可能会导致非连续的访问。 二维数组 二维数组是最常见的多维数组形式，可以看作是一个表格，由行和列组成。一个二维数组可以用两个索引来访问，第一个索引表示行，第二个索引表示列。\n声明和初始化 1 2 3 4 5 6 7 8 // 声明一个2x3的二维数组 int array[2][3]; // 初始化二维数组 int array[2][3] = { {1, 2, 3}, {4, 5, 6} }; 访问元素 1 2 3 4 5 // 访问第一个行的第一个列的元素 int element = array[0][0]; // 修改第一个行的第一个列的元素 array[0][0] = 10; 三维数组 三维数组可以看作是一个立方体，由层、行和列组成。一个三维数组可以用三个索引来访问，第一个索引表示层，第二个索引表示行，第三个索引表示列。\n声明和初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 声明一个2x3x4的三维数组 int array[2][3][4]; // 初始化三维数组 int array[2][3][4] = { { {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12} }, { {13, 14, 15, 16}, {17, 18, 19, 20}, {21, 22, 23, 24} } }; 访问元素 1 2 3 4 5 // 访问第一个层的第一个行的第一个列的元素 int element = array[0][0][0]; // 修改第一个层的第一个行的第一个列的元素 array[0][0][0] = 10; 多维数组的应用 多维数组在实际编程中有很多应用，例如：\n图像处理：可以使用二维数组来表示图像的像素值。 三维模型：可以使用三维数组来表示物体的顶点和面。 表格数据：可以使用二维数组来存储和操作表格数据。 总结 多维数组是编程中用于存储多个维度数据的数据结构。常见的多维数组包括二维数组和三维数组。通过理解多维数组的特点和如何访问其元素，可以在实际编程中更高效地处理复杂数\n据。\n用C语言生成杨辉三角的两种方法（两个数组和一个数组）并举例 方法一：使用两个数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;stdio.h\u0026gt; #define ROWS 10 int main() { int triangle[ROWS][ROWS]; int i, j; // 初始化第一列和对角线为1 for (i = 0; i \u0026lt; ROWS; i++) { triangle[i][0] = 1; triangle[i][i] = 1; } // 计算其他位置的值 for (i = 2; i \u0026lt; ROWS; i++) { for (j = 1; j \u0026lt; i; j++) { triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j]; } } // 打印杨辉三角 for (i = 0; i \u0026lt; ROWS; i++) { for (j = 0; j \u0026lt;= i; j++) { printf(\u0026#34;%d \u0026#34;, triangle[i][j]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 方法二：使用一个数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;stdio.h\u0026gt; #define ROWS 10 int main() { int triangle[ROWS]; int i, j; // 初始化第一行为1 triangle[0] = 1; // 打印第一行 printf(\u0026#34;%d\\n\u0026#34;, triangle[0]); // 计算并打印其他行 for (i = 1; i \u0026lt; ROWS; i++) { triangle[i] = 1; for (j = i - 1; j \u0026gt; 0; j--) { triangle[j] += triangle[j - 1]; } for (j = 0; j \u0026lt;= i; j++) { printf(\u0026#34;%d \u0026#34;, triangle[j]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 这两种方法都可以生成杨辉三角，你可以根据自己的需求选择使用哪种方法。\n如何利用这两种方法输出金字塔形的杨辉三角 要输出金字塔形的杨辉三角，我们可以在上述两种方法的基础上进行修改，主要是调整打印格式。以下是修改后的代码：\n方法一：使用两个数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;stdio.h\u0026gt; #define ROWS 10 int main() { int triangle[ROWS][ROWS]; int i, j; // 初始化第一列和对角线为1 for (i = 0; i \u0026lt; ROWS; i++) { triangle[i][0] = 1; triangle[i][i] = 1; } // 计算其他位置的值 for (i = 2; i \u0026lt; ROWS; i++) { for (j = 1; j \u0026lt; i; j++) { triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j]; } } // 打印金字塔形杨辉三角 for (i = 0; i \u0026lt; ROWS; i++) { // 打印空格，形成金字塔形状 for (j = 0; j \u0026lt; ROWS - i - 1; j++) { printf(\u0026#34; \u0026#34;); } for (j = 0; j \u0026lt;= i; j++) { printf(\u0026#34;%d \u0026#34;, triangle[i][j]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 方法二：使用一个数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;stdio.h\u0026gt; #define ROWS 10 int main() { int triangle[ROWS]; int i, j; // 初始化第一行为1 triangle[0] = 1; // 打印第一行 printf(\u0026#34; \u0026#34;); // 打印一个空格，使金字塔形状更明显 printf(\u0026#34;%d\\n\u0026#34;, triangle[0]); // 计算并打印其他行 for (i = 1; i \u0026lt; ROWS; i++) { triangle[i] = 1; for (j = i - 1; j \u0026gt; 0; j--) { triangle[j] += triangle[j - 1]; } // 打印空格，形成金字塔形状 for (j = 0; j \u0026lt; ROWS - i - 1; j++) { printf(\u0026#34; \u0026#34;); } for (j = 0; j \u0026lt;= i; j++) { printf(\u0026#34;%d \u0026#34;, triangle[j]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 这两种方法都会输出金字塔形的杨辉三角。方法一是使用二维数组来存储杨辉三角的每一行，而方法二则是使用一维数组来存储当前行的值，并通过计算得到下一行的值。\nC语言中do\u0026hellip;\u0026hellip;while\u0026hellip;\u0026hellip;循环是干什么的 在C语言中，do\u0026hellip;while循环是一种先执行循环体，然后再判断循环条件的循环结构。它的基本语法如下：\n1 2 3 do { // 循环体语句 } while (条件表达式); do\u0026hellip;while循环的执行过程如下：\n执行do后面的循环体语句。 计算while后面的条件表达式。 如果条件表达式的值为真（非零），则返回步骤1继续执行循环体； 如果条件表达式的值为假（零），则循环结束。 与while循环不同的是，do\u0026hellip;while循环的循环体至少会执行一次，即使条件表达式在第一次判断时就为假。这是因为do\u0026hellip;while循环是先执行循环体，然后再判断条件。\n例如，下面的代码使用do\u0026hellip;while循环来计算用户输入的数字之和，直到用户输入负数为止：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; int main() { int num, sum = 0; do { printf(\u0026#34;请输入一个数字（输入负数结束）：\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;num); sum += num; } while (num \u0026gt;= 0); printf(\u0026#34;输入的数字之和为：%d\\n\u0026#34;, sum); return 0; } 在这个例子中，do\u0026hellip;while循环会先执行循环体，要求用户输入一个数字，并将其累加到sum变量中。然后判断num是否小于0，如果不是，则继续执行循环体；如果是，则循环结束。\n打印斐波那契数列的两种方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; int main() { unsigned long long w, u = 1, v = 1, j; scanf(\u0026#34;%12llu\u0026#34;, \u0026amp;j); printf(\u0026#34;%12llu %12llu\u0026#34;, u, v); for(int k = 3; k \u0026lt;= j; k++){ w = v + u; u = v; v = w; printf(\u0026#34; %12llu\u0026#34;,w); } } Another solution:\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdio.h\u0026gt; int main() { int k = 3; do { k++; w = u + v; u = v; v = w; printf(\u0026#34; %12llu\u0026#34;,w); } while (k \u0026lt;= j); } C语言中if循环、while循环和do\u0026hellip;while循环的区别 在C语言中，if语句、while循环和do...while循环是用于控制程序流程的不同结构。它们之间的主要区别在于执行条件判断的时机和循环体执行的次数。\n1. if语句 if语句用于根据一个条件来决定是否执行某个代码块。\n它只执行一次条件判断，如果条件为真，则执行相应的代码块；如果条件为假，则不执行。\n语法：\n1 2 3 if (条件表达式) { 代码块 } 2. while循环 while循环用于在条件为真时重复执行一个代码块。\n它先进行条件判断，如果条件为真，则执行循环体，然后再次进行条件判断，以此类推，直到条件为假时退出循环。\n语法：\n1 2 3 while (条件表达式) { 代码块 } 3. do\u0026hellip;while循环 do...while循环也用于在条件为真时重复执行一个代码块。\n它与while循环的不同之处在于，它先执行一次循环体，然后再进行条件判断。因此，do...while循环的循环体至少会执行一次。\n语法：\n1 2 3 do { 代码块 } while (条件表达式); 区别总结 执行顺序： if语句：先判断条件，再执行代码块（执行0次或1次）。 while循环：先判断条件，再执行代码块（执行0次或多次）。 do...while循环：先执行代码块，再判断条件（执行1次或多次）。 循环体执行次数： if语句：执行0次或1次。 while循环：执行0次或多次。 do...while循环：执行1次或多次。 条件判断时机： if语句和while循环：在循环体执行之前判断条件。 do...while循环：在循环体执行之后判断条件。 根据具体的需求，选择合适的控制结构可以使代码更加清晰和高效。\nC语言中如果我定义了一个数组i[5][6][9][7][10]，那么i[3][5][7]是什么意思，并举个例子\n在C语言中，如果你定义了一个五维数组i[5][6][9][7][10]，那么i[3][5][7]指的是这个五维数组中的一个特定元素。具体来说，它是在第一维上取索引为3，第二维上取索引为5，第三维上取索引为7的元素。\n五维数组可以看作是一个由多个四维数组组成的数组，每个四维数组又由多个三维数组组成，以此类推。因此，i[3][5][7]实际上是访问了这个数组中的一个三维数组。\n为了更清楚地理解，我们可以将这个五维数组想象成一个五层的立方体，每一层都有6x9x7x10个元素。i[3][5][7]就是在这个立方体的第四层（因为索引从0开始），第五行（因为索引从0开始），第八列（因为索引从0开始）的那个元素。\n请注意，C语言中的数组索引是从0开始的，这意味着第一个元素的索引是0，而不是1。因此，i[3][5][7]实际上是访问了这个数组中的第4个、第6个和第8个元素（在各自的维度上）。\nC\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;stdio.h\u0026gt; int main() { // 定义一个五维数组 int i[5][6][9][7][10]; // 初始化数组元素 for (int a = 0; a \u0026lt; 5; a++) { for (int b = 0; b \u0026lt; 6; b++) { for (int c = 0; c \u0026lt; 9; c++) { for (int d = 0; d \u0026lt; 7; d++) { for (int e = 0; e \u0026lt; 10; e++) { i[a][b][c][d][e] = a * 1000 + b * 100 + c * 10 + d * 1 + e; } } } } } // 打印特定元素的值 printf(\u0026#34;The value of i[3][5][7] is: %d\\n\u0026#34;, i[3][5][7]); return 0; } 在这个例子中，我们定义了一个五维数组i，并使用五个嵌套的循环来初始化数组中的每个元素。每个元素的值是通过将其索引值组合而成的。然后，我们打印出i[3][5][7]的值，这是数组中第四层、第五行、第八列的元素的值。\n运行这段代码，你会看到输出结果为：\n1 The value of i[3][5][7] is: 3570 这个结果符合我们的预期，因为i[3][5][7]的值是由索引值3、5、7组合而成的，即3570。\n前置自增（++i）和后置自增（i++）有什么区别？ 运算顺序 前置自增（++i） 先将变量 i 的值加 1，然后再使用 i 的值进行表达式的计算。例如： 1 2 int i = 5; int a = ++i; 在这里，首先 i 的值变为 6，然后将 6 赋值给 a，所以 a 的值为 6，i 的值也为 6。 后置自增（i++） 先使用变量 i 的值进行表达式的计算，然后再将 i 的值加 1。例如： 1 2 int i = 5; int a = i++; 首先将 i 的当前值 5 赋值给 a，然后 i 的值变为 6。所以 a 的值为 5，i 的值为 6。 返回值不同 前置自增（++i） 前置自增表达式的值是自增后变量的值。例如在int a = ++i;中，++i 返回的是 i 自增后的值。 后置自增（i++） 后置自增表达式的值是变量自增前的值。例如在int a = i++;中，i++ 返回的是 i 自增前的值。 在表达式中的应用差异 前置自增（++i） 如果在一个复杂表达式中使用前置自增，变量会先自增，再参与表达式运算。例如： 1 2 int i = 5; int a = (++i) * 2; 首先 i 变为 6，然后 6 * 2 的结果 12 赋值给 a。 后置自增（i++） 在复杂表达式中使用后置自增时，变量先参与表达式运算，然后自增。例如： 1 2 int i = 5; int a = (i++) * 2; 首先 5 * 2 的结果 10 赋值给 a，然后 i 变为 6。 效率方面（在某些情况下） 前置自增（++i） 对于用户自定义类型（如结构体等），前置自增通常更高效。因为前置自增只需要对变量进行一次操作（先自增再返回）。 后置自增（i++） 对于用户自定义类型，后置自增相对效率较低。因为它需要先保存变量的原始值用于返回，然后再对变量进行自增操作，涉及更多的步骤。不过对于基本数据类型，现代编译器通常会进行优化，这种效率差异往往可以忽略不计。 C语言中各种排序 1.直接选择排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;stdio.h\u0026gt; #define m 10 int main() { int i, j, k, r, a[m]; printf(\u0026#34;please input achievement:\\n\u0026#34;); for (i = 0; i \u0026lt; m; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } for (i = 0; i \u0026lt; m - 1; i++) { j = i; for (k = i + 1; k \u0026lt; m; k++) { if (a[k] \u0026lt; a[j]) { j = k; } } r = a[i]; a[i] = a[j]; a[j] = r; } printf(\u0026#34;answer:\\n\u0026#34;); for (i = 0; i \u0026lt; m; i++) { if (i % 10 == 0) { printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;%6d\u0026#34;, a[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } 1.1进阶版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;stdio.h\u0026gt; // 排序函数，采用选择排序的变种 void Sort(int a[], int len) { int min, max, temp, i, j; // 声明必要的变量 // 循环直到中间位置 for (i = 0; i \u0026lt; len / 2; i++) { min = i; // 假设当前最小值的索引为i max = i; // 假设当前最大值的索引为i // 寻找当前未排序部分的最小值和最大值 for (j = i + 1; j \u0026lt;= len - 1 - i; j++) { // 如果找到更小的值，更新min的索引 if (a[j] \u0026lt; a[min]) min = j; // 如果找到更大的值，更新max的索引 else if (a[j] \u0026gt; a[max]) max = j; } // 如果找到的最小值不在当前位置i，交换位置 if (min != i) { temp = a[i]; a[i] = a[min]; a[min] = temp; } // 如果最大值的索引仍为i，则更新为最小值的索引 if (max == i) max = min; // 如果找到的最大值不在当前位置的对称位置，交换位置 if (max != len - 1 - i) { temp = a[len - 1 - i]; a[len - 1 - i] = a[max]; a[max] = temp; } } } int main() { int a[10]; // 定义一个大小为10的数组 // 输入10个整数 for (int i = 0; i \u0026lt; 10; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } int len = sizeof(a) / sizeof(a[0]); // 计算数组的长度 // 调用排序函数进行排序 Sort(a, len); // 输出排序后的数组 for (int i = 0; i \u0026lt; len; i++) { printf(\u0026#34;%d \u0026#34;, a[i]); } printf(\u0026#34;\\n\u0026#34;); // 换行 return 0; // 程序结束返回0 } 2.冒泡排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;stdio.h\u0026gt; void bubblesort(int a[], int len) { for (int i = 0; i \u0026lt; len; i++) { for (int j = 0; j \u0026lt; len - 1; j++) { if (a[j] \u0026gt; a[j + 1]) { int tmp = a[j]; a[j] = a[j + 1]; a[j + 1] = tmp; } } } } int main() { int len, i; scanf(\u0026#34;%d\u0026#34;, \u0026amp;len); int s[len]; for (i = 0; i \u0026lt; len; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;s[i]); } bubblesort(s, len); printf(\u0026#34;answer:\\n\u0026#34;); for (i = 0; i \u0026lt; len; i++) { if (i % 5 == 0 \u0026amp;\u0026amp; i != 0) { printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;%3d\u0026#34;, s[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } or\u0026hellip;\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; void bubblesort(int s[], int len) { int i, r; bool flag; flag = true; while (flag) { flag = false; for (i = 0; i \u0026lt; len - 1; i++) { if (s[i] \u0026gt; s[i + 1]) { r = s[i]; s[i] = s[i + 1]; s[i + 1] = r; flag = true; } } } } int main() { int len, i; scanf(\u0026#34;%d\u0026#34;, \u0026amp;len); int s[len]; for (i = 0; i \u0026lt; len; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;s[i]); } bubblesort(s, len); printf(\u0026#34;answer:\\n\u0026#34;); for (i = 0; i \u0026lt; len; i++) { if (i % 5 == 0 \u0026amp;\u0026amp; i != 0) { printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;%3d\u0026#34;, s[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } 3.直接插入排序 基本步骤：\n首先，将数组中的第一个元素看作是一个初始的有序序列（长度为 1）。 然后，从第二个元素开始（即对于未排序数据），依次取出每个元素。 对于取出的每个未排序元素，在已有的有序序列中从后向前进行扫描比较。 如果该未排序元素小于已排序序列中的当前比较元素，就将已排序序列中的当前比较元素向后移动一位。 持续这个比较和移动的过程，直到找到合适的位置，将未排序元素插入到该位置，使得插入后新的序列依然有序。\n代码: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;stdio.h\u0026gt; void sort(int n, int a[]) { int i, j, k, r; for (i = 1; i \u0026lt; n; i++) { j = i - 1; while ((a[j] \u0026gt; a[i]) \u0026amp;\u0026amp; (j \u0026gt;= 0)) { j = j - 1; } r = a[i]; for (k = i - 1; k \u0026gt;= j + 1; k--) { a[k + 1] = a[k]; } a[j + 1] = r; } } int main() { int len, i; scanf(\u0026#34;%d\u0026#34;, \u0026amp;len); int s[len]; for (i = 0; i \u0026lt; len; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;s[i]); } sort(len, s); printf(\u0026#34;answer:\\n\u0026#34;); for (i = 0; i \u0026lt; len; i++) { if (i % 5 == 0 \u0026amp;\u0026amp; i != 0) { printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;%3d\u0026#34;, s[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } 4.归并排序 基本概念 归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide - and - Conquer）的一个非常典型的应用。\n原理 分治思想 分解：将一个长度为 n 的数组分成两个长度大致为 n/2 的子数组，然后对每个子数组继续分解，直到子数组的长度为 1。 合并：将两个或多个已经有序的子数组合并成一个有序数组。从最小的子数组开始，逐步合并成较大的有序数组，最终得到一个完全有序的数组。 合并过程 假设要合并两个有序子数组 A 和 B（分别记为 A = [a1, a2, …, am] 和 B = [b1, b2, …, bn]），创建一个临时数组 C 来存储合并后的结果。 比较 A 和 B 的第一个元素，将较小的元素放入 C 中。如果 A 的第一个元素较小，就将 a1 放入 C 中，然后考虑 A 中的下一个元素 a2；如果 B 的第一个元素较小，就将 b1 放入 C 中，然后考虑 B 中的下一个元素 b2。 重复这个比较和放入的过程，直到 A 或 B 中的所有元素都被放入 C 中。 如果 A 中还有剩余元素，将它们全部放入 C 中；如果 B 中还有剩余元素，也将它们全部放入 C 中。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include \u0026lt;stdio.h\u0026gt; void merge(int arr[], int tmp[], int left, int mid, int right) { int i, j, t; for (i = left, j = mid + 1, t = left; i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= right; t++) { if (arr[i] \u0026lt;= arr[j]) { tmp[t] = arr[i], i++; } else { tmp[t] = arr[j], j++; } } for (; i \u0026lt;= mid; i++) { tmp[t] = arr[i]; t++; } for (; j \u0026lt;= right; j++) { tmp[t++] = arr[j]; t++; } for (t = left; t \u0026lt;= right; t++) { arr[t] = tmp[t]; } } void msort(int arr[], int tmp[], int left, int right) { int mid; if (left != right) { mid = (left + right) / 2; msort(arr, tmp, left, mid); msort(arr, tmp, mid + 1, right); merge(arr, tmp, left, mid, right); } } void mergesort(int arr[], int len) { int tmp[len]; msort(arr, tmp, 0, len - 1); } int main() { int len, i; scanf(\u0026#34;%d\u0026#34;, \u0026amp;len); int s[len]; for (i = 0; i \u0026lt; len; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;s[i]); } mergesort(s, len); printf(\u0026#34;answer:\\n\u0026#34;); for (i = 0; i \u0026lt; len; i++) { if (i % 5 == 0 \u0026amp;\u0026amp; i != 0) { printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;%3d\u0026#34;, s[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } Q 在C语言中*ptr++和(*ptr)++有区别吗 在 C 语言中，*ptr++和(*ptr)++有区别。\n*ptr++： 这个表达式的作用是先取*ptr的值，然后将指针ptr向后移动一位（指向下一个存储单元）。 例如，如果ptr指向一个整数数组，假设初始时ptr指向数组的第一个元素，执行*ptr++后，会得到第一个元素的值，并且ptr指向数组的第二个元素。 (*ptr)++： 这个表达式是先取指针ptr所指向的内容，然后将这个内容的值加 1。 例如，如果ptr指向一个整数，执行(*ptr)++后，ptr所指向的整数的值会增加 1。 以下是一段 C 语言代码示例，演示*ptr++和(*ptr)++的不同用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; int main() { int arr[] = {10, 20, 30}; int *ptr = arr; // 演示 *ptr++ printf(\u0026#34;*ptr++ 的结果：\\n\u0026#34;); printf(\u0026#34;初始 ptr 指向的值：%d\\n\u0026#34;, *ptr); printf(\u0026#34;执行 *ptr++ 后 ptr 指向的值：%d\\n\u0026#34;, *ptr++); printf(\u0026#34;再次执行 *ptr++ 后 ptr 指向的值：%d\\n\u0026#34;, *ptr++); ptr = arr; // 将 ptr 重新指向数组首地址 // 演示 (*ptr)++ printf(\u0026#34;\\n(*ptr)++ 的结果：\\n\u0026#34;); printf(\u0026#34;初始 ptr 指向的值：%d\\n\u0026#34;, *ptr); printf(\u0026#34;执行 (*ptr)++ 后 ptr 指向的值：%d\\n\u0026#34;, (*ptr)++); printf(\u0026#34;再次执行 (*ptr)++ 后 ptr 指向的值：%d\\n\u0026#34;, (*ptr)++); return 0; } 在这个示例中，首先展示了*ptr++的用法，它先取出ptr指向的值，然后ptr自增指向下一个元素。接着展示了(*ptr)++的用法，它取出ptr指向的值并将该值加 1。\n","date":"2024-11-03T00:00:00Z","permalink":"https://zhao20060708.github.io/p/c-language/","title":"C language"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block 1 \u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-07T00:00:00Z","permalink":"https://zhao20060708.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo theme Stack supports the creation of interactive image galleries using Markdown. It\u0026rsquo;s powered by PhotoSwipe and its syntax was inspired by Typlog.\nTo use this feature, the image must be in the same directory as the Markdown file, as it uses Hugo\u0026rsquo;s page bundle feature to read the dimensions of the image. External images are not supported.\nSyntax 1 ![Image 1](1.jpg) ![Image 2](2.jpg) Result Photo by mymind and Luke Chesser on Unsplash\n","date":"2023-08-26T00:00:00Z","image":"https://zhao20060708.github.io/p/image-gallery/2_hu_3e58a979f20e4e46.jpg","permalink":"https://zhao20060708.github.io/p/image-gallery/","title":"Image gallery"},{"content":"For more details, check out the documentation.\nBilibili video Tencent video YouTube video Generic video file Your browser doesn't support HTML5 video. Here is a link to the video instead. Gist GitLab Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Photo by Codioful on Unsplash\n","date":"2023-08-25T00:00:00Z","image":"https://zhao20060708.github.io/p/shortcodes/cover_hu_5667347daefb4230.jpg","permalink":"https://zhao20060708.github.io/p/shortcodes/","title":"Shortcodes"},{"content":"Stack has built-in support for math typesetting using KaTeX.\nIt\u0026rsquo;s not enabled by default side-wide, but you can enable it for individual posts by adding math: true to the front matter. Or you can enable it side-wide by adding math = true to the params.article section in config.toml.\nInline math This is an inline mathematical expression: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n1 $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$ Block math $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ 1 2 3 $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ 1 2 3 $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ ","date":"2023-08-24T00:00:00Z","permalink":"https://zhao20060708.github.io/p/math-typesetting/","title":"Math Typesetting"}]