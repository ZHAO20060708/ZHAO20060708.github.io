[{"content":"呐\u0026hellip;\u0026hellip;不知道说什么好呢 这里是Eric Zhao，一个平平无奇的双学位大学生，目前就读于长春某985院校（长春好像就一个985），随缘更新编程、数学相关内容（以及商学与管理学）\n注意 以后的文章如果不另外说明均在\n平台上运行（基于archlinux）（大 家 快 来 使 endeavouros ！）\nWant a site like this? Check out hugo-theme-stack-stater\nPhoto by Pawel Czerwinski on Unsplash\n","date":"2024-11-05T00:00:00Z","image":"https://zhao20060708.github.io/p/hello-world/cover_hu6307248181568134095.jpg","permalink":"https://zhao20060708.github.io/p/hello-world/","title":"Hello World"},{"content":" 第一优先级：括号运算符（()）和数组下标运算符（[]）以及成员访问运算符（.和-\u0026gt;） 括号运算符用于改变运算顺序。例如(a + b)*c，先计算括号内的a + b。 数组下标运算符用于访问数组元素，如a[3]。 成员访问运算符用于访问结构体或联合体中的成员，如struct student s; s.age（通过对象访问）或者struct student *p; p-\u0026gt;age（通过指针访问）。 第二优先级：一元运算符（如++、\u0026ndash;、!、~、-、+、*、\u0026amp;） 自增（++）和自减（--）运算符有前置和后置之分。前置是先改变变量的值再使用，后置是先使用变量的值再改变。例如int a = 1; int b=++a;（b的值为2，a的值为2），int c = 1; int d = c++;（d的值为1，c的值为2）。 !是逻辑非运算符，将真变为假，假变为真。例如int a = 0; int b=!a;（b的值为1）。 ~是按位取反运算符，对一个整数的二进制位进行取反操作。 -和+在这里作为一元运算符时，分别表示取负和取正。例如int a=-3;（取负），int b = +4;（取正，通常可以省略+）。 *作为一元运算符是指针运算符，用于访问指针所指向的内容。例如int a = 10; int *p=\u0026amp;a; int b=*p;（b的值为10）。 \u0026amp;是取地址运算符，用于获取变量的地址。例如int a; int *p = \u0026amp;a;获取a的地址并赋值给p。 第三优先级：算术运算符（乘除模：*、/、%） 乘法、除法和取模运算优先级相同。例如int a = 6/2*3;（先计算6/2得到3，再乘以3，结果为9），int b = 7%3;（结果为1）。 第四优先级：算术运算符（加减：+、-） 加法和减法优先级相同。例如int a = 3 + 4-2;（先计算3 + 4得到7，再减去2，结果为5）。 第五优先级：移位运算符（左移：\u0026laquo;，右移：\u0026raquo;） 左移运算符\u0026lt;\u0026lt;是将一个数的二进制位向左移动指定的位数，右边补0。例如int a = 1\u0026lt;\u0026lt;3;（1的二进制是00000001，左移3位后得到00001000，即8）。 右移运算符\u0026gt;\u0026gt;是将一个数的二进制位向右移动指定的位数。如果是无符号数，左边补0；如果是有符号数，左边补符号位。例如unsigned int b = 8\u0026gt;\u0026gt;2;（8的二进制是00001000，右移2位后得到00000010，即2）。 第六优先级：关系运算符（\u0026lt;、\u0026lt;=、\u0026gt;、\u0026gt;=） 用于比较两个值的大小关系。例如int a = 3; int b = 5; int c=a \u0026lt; b;（c的值为1，因为3小于5）。 第七优先级：关系运算符（==、!=） 用于判断两个值是否相等或不相等。例如int a = 3; int b = 3; int c=a == b;（c的值为1）。 第八优先级：逻辑与运算符（\u0026amp;\u0026amp;） 只有当两个操作数都为真时，结果才为真。例如int a = 1; int b = 0; int c=a \u0026amp;\u0026amp; b;（c的值为0）。 第九优先级：逻辑或运算符（||） 只要两个操作数中有一个为真，结果就为真。例如int a = 1; int b = 0; int c=a || b;（c的值为1）。 第十优先级：条件运算符（?:） 这是一个三目运算符，语法为表达式1?表达式2:表达式3。如果表达式1为真，则返回表达式2的值，否则返回表达式3的值。例如int a = 3; int b = 5; int c=(a \u0026gt; b)?a:b;（c的值为5）。 第十一优先级：赋值运算符（=、+=、-=、*=、/=、%=、\u0026laquo;=、\u0026raquo;=、\u0026amp;=、^=、|=） 基本的赋值运算符=用于将一个值赋给一个变量。例如int a; a = 3;。 复合赋值运算符是先进行算术或位运算，然后再赋值。例如int a = 3; a += 2;（相当于a = a+2，结果为5）。 第十二优先级：逗号运算符（,） 逗号运算符用于将多个表达式连接起来，从左到右依次计算表达式的值，整个逗号表达式的值等于最后一个表达式的值。例如int a = (3, 4, 5);（a的值为5）。 下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。\n类别 运算符 结合性 后缀 () [] -\u0026gt; . ++ -- 从左到右 一元 + - ! ~ ++ -- (type)* \u0026amp; sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 \u0026lt;\u0026lt; \u0026gt;\u0026gt; 从左到右 关系 \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= 从左到右 相等 == != 从左到右 位与 AND \u0026amp; 从左到右 位异或 XOR ^ 从左到右 位或 OR | 从左到右 逻辑与 AND \u0026amp;\u0026amp; 从左到右 逻辑或 OR || 从左到右 条件 ?: 从右到左 赋值 = += -= *= /= %= \u0026gt;\u0026gt;= \u0026lt;\u0026lt;= \u0026amp;= ^= |= 从右到左 逗号 , 从左到右 ","date":"2024-11-19T00:00:00Z","permalink":"https://zhao20060708.github.io/p/c%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8/","title":"C语言运算符优先级表"},{"content":"例2 设$ \\bm{X={1,2,\u0026hellip;,n,\u0026hellip;},Y={1,3,\u0026hellip;..2n-1,\u0026hellip;}} $, 对于任何一个$ \\bm{n\\in X} $ ,按照对应法则$ \\bm{f} $得到$ \\bm{2n-1\\in Y} $,则映射$ \\bm{f{:}X{\\to}Y} $是一一映射. 值得注意的是：$ \\bm{Y} $是$ \\bm{X} $ 的子集，$ \\bm{Y} $中的元素似乎比$ \\bm{X} $中的元素个数“少”,但实际是，在无限集合中，“部分可以等于整体”,这是无限集合的一个特性.$ \\bm{\\blacksquare} $ 并非所有的函数都有反函数,如$ y=f(x)=x^2 $, 定义域为$ D_f=(-∞,+∞) $\n, 值域为$ R_f=[0,+∞) $,显然$ f $不是一一映射,所以该函数没有反函数.\n但如果函数$ y=f(x) $是单调函数,则相应的映射必为一一映射,而相应的反函数必存在,故有如下结论：\n反函数存在定理:单调函数$ f $必存在单调的反函数,且此反函数与$ f $具有相同的单调性。\n注意: 不是任何两个的数都可以复合成一个复合函数的;\n例如，$ y = \\arcsin u，u=2+x^2；y≠\\arcsin(2+x^2) $ 复合函数可以由两个以上的函数经过复合构成。\n例如，$ y = \\sqrt{\\cot \\frac x2}，y=\\sqrt{u}，u=\\cot v，v=\\frac x2 $. 例9 判断函数 $ \\bm{f(x)=\\log_2\\left(x+\\sqrt{1+x^2}\\right)} $的奇偶性. 解: 函数$ f(x) $的定义域为$ (-\\infty,+\\infty). $对$ \\forall x $,由于\n$ f(-x)=\\log_{2}(-x+\\sqrt{1+\\left(-x\\right)^{2}})=\\log_{2}(\\sqrt{1+x^{2}}-x)\\\\=\\log_{2}\\frac{1}{\\sqrt{1+x^{2}}+x}=-\\log_{2}(x+\\sqrt{1+x^{2}})=-f(x), $\n所以函数$ f(x)=\\log_2(x+\\sqrt{1+x^2}) $是奇函数\n思考题1 已知$ \\bm{f(x)} $是一个偶函数，且满足$ \\bm{f(a+x)=f(a-x),} $则$ \\bm{f(x)} $是不是一个周期函数？若是，则说明它的一个周期，若不是，请说明理由 思考题解答 由$ f(a+x)=f(a-x) $可知：\n$ f(2a+x)=f[a+(a+x)]=f[a-(a+x)]=f\\left(-x\\right) $\n又因为$ f(x) $是一个偶函数， 所以$ f(2a+x)=f(x) $\n例1 求函数$ \\bm{y=\\sqrt{e^x+1}} $的反函数 解： $ \\because e^x=y^2-1 $\n$ \\therefore x=\\ln(y^2-1)\\quad y=\\sqrt{e^x+1}\\gt1 $，即原函数的值域为$ (1,+\\infty) $\n$ \\therefore $反函数为$ y=\\ln(x^2-1) $\n$ \\boldsymbol{D}_{f^{-1}}=(1,+\\infty) $\n例2 设$ \\bm{f(\\sin x)=\\cos2x+1} $,求$ \\bm{f(x)} $及$ \\bm{f(\\cos x).} $ 解： 因为$ f(\\sin x)=\\cos2x+1=1-2\\sin^2x+1=2-2\\sin^2x, $\n所以$ f\\left(x\\right)=2-2x^{2},\\quad f(\\cos x)=2-2\\cos^2x=2\\sin^2x. $\n例4 设函数 $ \\bm{f(x)} $的定义域为$ \\bm{(-l,l)} $, 证明必定存在$ \\bm{(-l,l)} $上的偶函数$ \\bm{g(x)} $及奇函数$ \\bm{h(x)} $,使得$ \\bm{f(x)=g(x)+h(x).} $ 分析 如果这样的$ g(x) $和$ h(x) $存在，于是\n$ \\begin{cases}f(x)=g(x)+h(x)\\\\f(-x)=g(-x)+h(-x)=g(x)-h(x)\\end{cases} $\n证明 设\n$ \\begin{cases}g(x)=\\frac12[f(x)+f(-x)]\\\\h(x)=\\frac12[f(x)-f(-x)]\\end{cases} $\n显然$ f\\left(x\\right)=g\\left(x\\right)+h\\left(x\\right). $\n$ g\\left(-x\\right)=\\frac12|f\\left(-x\\right)+f\\left(x\\right)|=|f\\left(x\\right) $是偶函数，\n$ -h(x)=\\frac12[f(-x)-f(x)]=h(-x) $是奇函数.\n已知 $ f(\\tan x)=\\sec^2x+1 $,求 $ f(x). $\n解：\n$ f(\\tan x)=\\left(\\tan^2x+1\\right)+1 $\n$ \\therefore f\\left(x\\right)=\\left(x^{2}+1\\right)+1=x^{2}+2 $\n思考题 分段函数一定不是初等函数吗？ 解答 不一定\n$y=\\begin{cases}x\u0026amp;x\\geq0\\\\-x\u0026amp;x\u0026lt;0\\end{cases}$\n它是一个分段函数， 但是，$ y=\\left|x\\right|=\\sqrt{x^{2}} $ 根据定义，它是一个初等函数。\n$ \\sin x+\\sin y=2\\sin\\frac{x+y}2\\cos\\frac{x-y}2 $\n$ \\sin x-\\sin y=2\\cos\\frac{x+y}2\\sin\\frac{x-y}2 $\n$ \\cos x+\\cos y=2\\cos\\frac{x+y}{2}\\cos\\frac{x-y}{2} $\n$ \\cos x-\\cos y=-2\\sin\\frac{x+y}{2}\\sin\\frac{x-y}{2} $\n$ \\sin x\\sin y=-\\frac{1}{2}[\\cos(x+y)-\\cos(x-y)] $\n$ \\cos x\\cos y=\\frac12[\\cos(x+y)+\\cos(x-y)] $\n$ \\sin x\\cos y=\\frac{1}{2}[\\sin(x+y)+\\sin(x-y)] $\n$ \\sin x=\\cos(x-\\frac{\\pi}{2}) $\n$ \\cos x=\\sin(x+\\frac{\\pi}{2}) $\n$ \\cos^{2}x-\\sin^{2}x=\\cos2x $\n$ \\sin^{2}x+\\cos^{2}x=1 $\n$ \\tan^{2}x+1=\\sec^{2}x $\n$ \\sin 2x=2\\sin x\\cos x $\n$ \\cot^{2}x+1=\\csc^{2}x $\n$ \\sin(x\\pm y)=\\sin x\\cos y\\pm\\cos x\\sin y $\n$ \\cos\\left(x\\pm y\\right)=\\cos x\\cos y\\mp\\sin x\\sin y $\n$ \\sin x+\\sin y=2\\sin\\frac{x+y}{2}\\cos\\frac{x-y}{2} $\n注意:数列极限的定义未给出求极限的方法。\n例1：证明$ \\bm{\\lim_{n\\to\\infty}\\frac{n+(-1)^{n-1}}n=1.} $ 证：\n$ |x_n-1|=\\left|\\frac{n+(-1)^{n-1}}n-1\\right|=\\frac1n $\n任给$ \\varepsilon\\gt0 $，要$ |x_n-1|\\lt\\varepsilon $,只要$ \\frac1n\\lt\\varepsilon, $或$ n\\gt\\frac1\\varepsilon $，\n给定$ \\frac1{100} $, 由$ \\frac1n\u0026lt;\\frac1{100} $,只要 $ n\u0026gt;100 $时，有$ |x_n-1|\u0026lt;\\frac1{100} $,\n给定$ \\frac1{1000} $,只要 $ n\u0026gt;1000 $ 时，有$ |x_n-1|\u0026lt;\\frac1{1000} $,\n给定$ \\frac1{10000} $,只要$ n\u0026gt;10000 $时，有$ |x_n-1|\u0026lt;\\frac1{10000} $,\n给定 $ \\varepsilon \u0026gt; 0 $, 只要 $ n\u0026gt;N(=\\begin{bmatrix} \\frac1\\varepsilon\\end{bmatrix}) $时，有$ |x_n-1|\u0026lt;\\varepsilon $成立.\n例2 设$ \\bm{x_n\\equiv C} $（$ \\bm{C} $为常数），证明$ \\bm{\\lim_{n\\to\\infty} x_n=C.} $ 证：\n任给$ \\varepsilon\u0026gt;0 $,对于一切正整数$ n $,\n$ |x_n-C|=|C-C|=0\u0026lt;\\varepsilon $成立，\n所以，$ \\lim_{n\\to\\infty} x_n=C. $\n说明：常数列的极限等于同一常数。\n小结：用定义证明数列极限存在时，关键是任意给定$ \\bm{\\varepsilon\u0026gt;0} $,寻找$ \\bm{N} $,但不必要求最小的$ \\bm{N} $.\n例3：设$ \\bm{|q|\u0026lt;1} $,证明等比数列$ \\bm{\\lim_{n\\to\\infty}q^n=0} $. 证：\nq=0时，等式显然成立。当$ 0\u0026lt;|q|\u0026lt;1 $,$ |x_n-0|=|q^n-0|=|q|^n $\n$ \\forall\\varepsilon\\in(0,1) $，要使$ \\left|x_n-0\\right|\u0026lt;\\varepsilon $，只要$ \\left|q\\right|^n\u0026lt;\\varepsilon $，\n即\n$ n\\ln | q| \u0026lt; \\ln \\varepsilon $,亦即$ n\u0026gt; \\frac {\\ln \\varepsilon }{\\ln | q| }. $\n因此，取 $ N= \\begin{bmatrix} \\frac {\\ln \\varepsilon }{\\ln | q| }\\end{bmatrix} $，则当$ n\u0026gt; N $时，就有$ |q^n-0|\u0026lt;\\varepsilon $,故$ \\lim_{n\\to\\infty}q^n=0 $.\n例4 证明数列 $ \\bm{x_n=(-1)^{n+1}} $是发散的 . 证：\n设$ \\lim_n\\to\\infty x_n=a $, 由定义，对于$ \\varepsilon=\\frac12 $,则$ \\exists N $,使得当$ n\u0026gt;N $时，有$ |x_n-a|\u0026lt;\\frac12 $成立，\n即当$ n\u0026gt;N $时$ , x_n\\in ( a- \\frac 12, a+ \\frac 12) $, 区间长度为1.\n而$ x_n $无休止地反复取1，-1两个数，不可能同时位于长度为1的区间内.\n事实上，$ {x_n} $是有界的 ,但却发散.\n$ (a+b) (a²-ab+b²)=a³+b³ $\n根据极限定义证明：函数$ f(x) $当$ x $趋近于$ x_0 $时 极限存在的充分必要条件是左极限、右极限各自存在并且相等 为了证明这个定理，我们需要分别从充分性和必要性两个 方面进行证明。\n充分性 假设函数 $ f(x) $ 在点 $ x_0 $ 处的左极限和右极限都存在且相等，即：\n$ \\lim_{x \\to x_0^-} f(x) = L \\quad \\text{和} \\quad \\lim_{x \\to x_0^+} f(x) = L $\n我们需要证明函数 $ f(x) $ 在点 $ x_0 $ 处的极限存在并且等于 $ L $。\n根据极限的定义，对于任意给定的小正数$ \\epsilon \u0026gt; 0 $，存在一个delta \u0026gt; 0，使得当$ 0 \u0026lt; |x - x_0| \u0026lt; \\delta $ 时，有：\n$ |f(x) - L| \u0026lt; \\epsilon $\n这个 delta 可以同时适用于左极限和右极限的定义。因为无论 $ x $ 是从左边还是右边接近$ x_0 $，只要 $ x $ 距离 $ x_0 $ 的距离小于$ \\delta $，$ f(x) $ 都会靠近 $ L $ 并且与 $ L $的差小于 $ \\epsilon $。\n因此，当 $ x $ 趋近于 $ x_0 $ 时，无论从left 或 right，$ f(x) $ 的极限都是 $ L $。所以，函数 $ f(x) $ 在点 $ x_0 $ 处的极限存在并且等于 $ L $。\n必要性 假设函数 $ f(x) $ 在点 $ x_0 $ 处的极限存在，记为\n$ L $，即：\n$ \\lim_{x \\to x_0} f(x) = L $\n我们需要证明函数 $ f(x) $ 在点 $ x_0 $ 处的左极限和右极限都存在并且相等。\n由于 $ f(x) $ 的极限在 $ x_0 $ 存在，对于任意给定的小正数 $ \\epsilon \u0026gt; 0 $，存在一个delta \u0026gt; 0，使得当$ 0 \u0026lt; |x - x_0| \u0026lt; \\delta $ 时，有：\n$ |f(x) - L| \u0026lt; \\epsilon $\n现在我们来分别考虑左极限和右极限。\n左极限：对于任意 $ \\epsilon \u0026gt; 0 $，存在\n$ \\delta^- \u0026gt; 0 $ 使得当 $ 0 \u0026lt; x_0 - x \u0026lt; \\delta^- $ 时，有： $$|f(x) - L| \u003c \\epsilon$$这说明当 $ x $ 从左边接近 $ x_0 $ 时，$ f(x) $ 趋近于$ L $。\n右极限：对于任意 $ \\epsilon \u0026gt; 0 $，存在$ \\delta^+ \u0026gt; 0 $ 使得当 $ 0 \u0026lt; x - x_0 \u0026lt;\\delta^+ $ 时，有： $$|f(x) - L| \u003c \\epsilon$$这说明当 $ x $ 从右边接近 $ x_0 $ 时，$ f(x) $ 趋近于$ L $。\n由于上述两个条件对于任意的 $ \\epsilon \u0026gt; 0 $ 都可以找到对应的 $ \\delta^- \u0026gt; 0 $ 和 $ \\delta^+ \u0026gt; 0 $，这意味着：\n$ \\lim_{x \\to x_0^-} f(x) = L \\quad \\text{和} \\quad \\lim_{x \\to x_0^+} f(x) = L $\n因此，函数 $ f(x) $ 在点 $ x_0 $ 处的左极限和右极限都存在并且相等。\n结论 综上所述，我们证明了：\n如果函数 $ f(x) $ 在点 $ x_0 $ 处的左极限和右极限都存在且相等，那么函数 $ f(x) $ 在点 $ x_0 $ 处的极限存在，并且等于这两个极限的共同值。 反之，如果函数 $ f(x) $ 在点 $ x_0 $ 处的极限存在，那么它的左极限和右极限也一定存在并且相等。 所以，函数 $ f(x) $ 在点 $ x_0 $ 处的极限存在的充分必要条件是其左极限和右极限都存在且相等。\n根据复合函数求导法则， $ \\frac{d}{dx} f(u) = f^\\prime(u) \\cdot u^\\prime $\n当 $ x \\to 0 $ 时，\n$ x \\sim \\sin x \\sim \\tan x \\sim \\arcsin x \\sim \\arctan x \\sim \\ln(1 + x) \\sim e^x - 1 $;\n$ 1 - \\cos x \\sim \\frac{x^2}{2} $;\n$ (1 + x)^a - 1 \\sim ax\\ (a \\neq 0) $;\n$ a^x - 1 \\sim x \\ln a(a \u0026gt; 0, a \\neq 1) $.\n基本初等函数的求导公式 (1) $ (C)'= 0 $$ (C为常数)\n(2) $(x\\mu)\u0026rsquo; = \\mu x{\\mu - 1}$\n(3) $(\\sin x)\u0026rsquo; = \\cos x$\n(4) $(\\cos x)\u0026rsquo; = - \\sin x$\n(5) $(\\tan x)\u0026rsquo; = \\sec^2 x$\n(6) $(\\cot x)\u0026rsquo; = - \\csc^2 x$\n(7) $(\\sec x)\u0026rsquo; = \\sec x \\tan x$\n(8) $(\\csc x)\u0026rsquo; = - \\csc x \\cot x$\n(9) $(ax)\u0026rsquo; = ax \\ln a$\n(10) $(ex)\u0026rsquo; = ex$\n(11) $(\\log_a x)\u0026rsquo; = \\frac{1}{x \\ln a}$\n(12) $(\\ln x)\u0026rsquo; = \\frac{1}{x}$\n(13) $(\\arcsin x)\u0026rsquo; = \\frac{1}{\\sqrt{1 - x^2}}$\n(14) $(\\arccos x)\u0026rsquo; = \\frac{-1}{\\sqrt{1 - x^2}}$\n(15) $(\\arctan x)\u0026rsquo; = \\frac{1}{1 + x^2}$\n(16) $(\\text{arccot } x)\u0026rsquo; = \\frac{-1}{1 + x^2}$\n基本初等函数的微分公式 (1) $ \\mathrm{d}C = 0 $ (c为常数)\n(2) $ \\mathrm{d}x^\\mu = \\mu x^{\\mu - 1} \\mathrm{d}x $\n(3) $ \\mathrm{d} \\sin x = \\cos x \\mathrm{d}x $\n(4) $ \\mathrm{d} \\cos x = - \\sin x \\mathrm{d}x $\n(5) $ \\mathrm{d} \\tan x = \\sec^2 x \\mathrm{d}x $\n(6) $ \\mathrm{d} \\cot x = - \\csc^2 x \\mathrm{d}x $\n(7) $ \\mathrm{d} \\sec x = \\sec x \\tan x \\mathrm{d}x $\n(8) $ \\mathrm{d} \\csc x = - \\csc x \\cot x \\mathrm{d}x $\n(9) $ \\mathrm{d}a^x = a^x \\ln a \\mathrm{d}x $\n(10) $ \\mathrm{d}e^x = e^x \\mathrm{d}x $\n(11) $ \\mathrm{d} \\log_a x = \\frac{1}{x \\ln a} \\mathrm{d}x $\n(12) $ \\mathrm{d} \\ln x = \\frac{1}{x} \\mathrm{d}x $\n(13) $\\mathrm{d} \\arcsin x = \\frac{1}{\\sqrt{1 - x^2}} \\mathrm{d}x$\n(14) $\\mathrm{d} \\arccos x = \\frac{-1}{\\sqrt{1 - x^2}} \\mathrm{d}x$\n(15) $\\mathrm{d} \\arctan x = \\frac{1}{1 + x^2} \\mathrm{d}x$\n(16) $\\mathrm{d} \\text{ arccot } x = \\frac{-1}{1 + x^2} \\mathrm{d}x$\n一些需要注意的点 存在原函数的偶函数其原函数不一定是奇函数。只有当原函数中的常数项为 0 时，原函数才是奇函数。 收敛数列的性质 收敛数列极限唯一 收敛数列必有界 推论 无界数列必发散（2.的逆否命题） 有界数列未必收敛 保号性 若$x_n→a,y_n→b$，则$\\exists N \\in \\bold{N^+}$，当$n \u0026gt; N$ 时，有$x_n\u0026gt;y_n$. 若$x_n→a$，且$a \u0026lt; 0(a \u0026gt; 0)$，则$\\exists N \\in \\bold{N^+}$，当$n \u0026gt; N$ 时，有$x_n\u0026lt;0(x_n\u0026gt;0)$. 推论： $x_n→a,y_n→b$，若$x_n \\geq y_n$，则$a\\geq b$. $x_n→a,y_n→b$，若$x_n \\geq y_n$，则$a\\geq b$. 麦克劳林级数 几何级数 $\\frac{1}{1 - x} = \\sum_{n=0}^{\\infty} x^n = 1 + x + x^2 + x^3 + \u0026hellip; + x^n + \u0026hellip; \\qquad \\forall x:|x| \u0026lt; 1$\n二项式级数 $\\sum_{n=0}^{\\infty} \\binom{n}{k} x^n = (1 + x)^k=1 + kx + \\frac{k(k-1)}{2!}x^2 + \\frac{k(k-1)(k-2)}{3!}x^3 + \u0026hellip; + \\frac{k(k-1)\u0026hellip;(k-n+1)}{n!}x^n + \u0026hellip; \\qquad \\forall x: |x| \u0026lt; 1, \\forall k: k \\in \\mathbb{C}$\n指数函数 $e^x = \\sum_{n=0}^{\\infty} \\frac{x^n}{n!} = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \u0026hellip; + \\frac{x^n}{n!} + \u0026hellip; \\qquad \\forall x$\n自然对数 $\\ln(1 - x) = \\sum_{n=1}^{\\infty} \\frac{x^n}{n} = -x + \\frac{x^2}{2} - \\frac{x^3}{3} + \u0026hellip; + (-1)^{n+1} \\frac{x^n}{n} + \u0026hellip; \\qquad \\forall x: |x| \u0026lt; 1$\n$\\ln(1 + x) = \\sum_{n=1}^{\\infty} \\frac{(-1)^{n+1}x^n}{n} = x - \\frac{x^2}{2} + \\frac{x^3}{3} - \u0026hellip; + (-1)^{n+1} \\frac{x^n}{n} + \u0026hellip; \\qquad \\forall x: |x| \u0026lt; 1$\n三角函数 $\\sin x = \\sum_{n = 0}^{\\infty} \\frac{(-1)^n x^{2n + 1}}{(2n + 1)!} = x - \\frac{x^3}{3!} + \\frac{x^5}{5!} - \\cdots \\quad \\forall x$\n$\\cos x = \\sum_{n = 0}^{\\infty} \\frac{(-1)^n x^{2n}}{(2n)!} = 1 - \\frac{x^2}{2!} + \\frac{x^4}{4!} - \\cdots \\quad \\forall x$\n$\\tan x = \\sum_{n = 1}^{\\infty} \\frac{B_{2n} (-4)^n (1 - 4^n)}{(2n)!} x^{2n - 1} = x + \\frac{2x^5}{15} + \\cdots \\quad \\forall x : |x| \u0026lt; \\frac{\\pi}{2}$\n$\\sec x = \\sum_{n = 0}^{\\infty} \\frac{(-1)^n E_{2n} x^{2n}}{(2n)!} = 1 + \\frac{x^2}{2} + \\frac{5x^4}{24} + \\cdots \\quad \\forall x : |x| \u0026lt; \\frac{\\pi}{2}$\n$\\arcsin x = \\sum_{n = 0}^{\\infty} \\frac{(2n)!}{4^n (n!)^2 (2n + 1)} x^{2n + 1} = x + \\frac{x^3}{6} + \\frac{3x^5}{40} + \\cdots \\quad \\forall x : |x| \\leq 1$\n$\\arccos x = \\frac{\\pi}{2} - \\arcsin x = \\frac{\\pi}{2} - \\sum_{n = 0}^{\\infty} \\frac{(2n)!}{4^n (n!)^2 (2n + 1)} x^{2n + 1} = \\frac{\\pi}{2} - x - \\frac{x^3}{6} - \\frac{3x^5}{40} + \\cdots \\quad \\forall x : |x| \\leq 1$\n$\\arctan x = \\sum_{n = 0}^{\\infty} \\frac{(-1)^n x^{2n + 1}}{2n + 1} = x - \\frac{x^3}{3} + \\frac{x^5}{5} - \\cdots \\quad \\forall x : |x| \\leq 1, x \\neq \\pm i$\n","date":"2024-11-05T00:00:00Z","permalink":"https://zhao20060708.github.io/p/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/","title":"数学笔记"},{"content":"C语言中如何表示阶乘 在C语言中，阶乘通常使用循环来实现。以下是一个使用for循环计算阶乘的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;stdio.h\u0026gt; long long factorial(int n) { long long result = 1; for (int i = 1; i \u0026lt;= n; i++) { result *= i; } return result; } int main() { int num; printf(\u0026#34;请输入一个正整数：\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;num); if (num \u0026lt; 0) { printf(\u0026#34;输入的数必须是正整数！\\n\u0026#34;); } else { long long fact = factorial(num); printf(\u0026#34;%d 的阶乘是 %lld\\n\u0026#34;, num, fact); } return 0; } 在这个示例中，factorial 函数接受一个整数参数 n，并使用一个for循环从1到 n 遍历，将每个数累乘到 result 变量中，最终返回 result 作为阶乘的结果。在 main 函数中，我们提示用户输入一个正整数，然后调用 factorial 函数计算并输出阶乘结果。如果输入的数不是正整数，程序会输出错误提示信息。\n多维数组是什么，详细解释一下，并告诉我如何用C语言实现 多维数组是指在编程中用于存储多个维度数据的数组。多维数组可以看作是嵌套的数组，每一维都包含一个子数组。常见的多维数组包括二维数组、三维数组等。\n多维数组的特点 维度：多维数组有多个维度，每个维度可以有不同的长度。 索引：访问多维数组中的元素需要使用多个索引，每个索引对应一个维度。 内存布局：多维数组在内存中是连续存储的，但索引的方式可能会导致非连续的访问。 二维数组 二维数组是最常见的多维数组形式，可以看作是一个表格，由行和列组成。一个二维数组可以用两个索引来访问，第一个索引表示行，第二个索引表示列。\n声明和初始化 1 2 3 4 5 6 7 8 // 声明一个2x3的二维数组 int array[2][3]; // 初始化二维数组 int array[2][3] = { {1, 2, 3}, {4, 5, 6} }; 访问元素 1 2 3 4 5 // 访问第一个行的第一个列的元素 int element = array[0][0]; // 修改第一个行的第一个列的元素 array[0][0] = 10; 三维数组 三维数组可以看作是一个立方体，由层、行和列组成。一个三维数组可以用三个索引来访问，第一个索引表示层，第二个索引表示行，第三个索引表示列。\n声明和初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 声明一个2x3x4的三维数组 int array[2][3][4]; // 初始化三维数组 int array[2][3][4] = { { {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12} }, { {13, 14, 15, 16}, {17, 18, 19, 20}, {21, 22, 23, 24} } }; 访问元素 1 2 3 4 5 // 访问第一个层的第一个行的第一个列的元素 int element = array[0][0][0]; // 修改第一个层的第一个行的第一个列的元素 array[0][0][0] = 10; 多维数组的应用 多维数组在实际编程中有很多应用，例如：\n图像处理：可以使用二维数组来表示图像的像素值。 三维模型：可以使用三维数组来表示物体的顶点和面。 表格数据：可以使用二维数组来存储和操作表格数据。 总结 多维数组是编程中用于存储多个维度数据的数据结构。常见的多维数组包括二维数组和三维数组。通过理解多维数组的特点和如何访问其元素，可以在实际编程中更高效地处理复杂数\n据。\n用C语言生成杨辉三角的两种方法（两个数组和一个数组）并举例 方法一：使用两个数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;stdio.h\u0026gt; #define ROWS 10 int main() { int triangle[ROWS][ROWS]; int i, j; // 初始化第一列和对角线为1 for (i = 0; i \u0026lt; ROWS; i++) { triangle[i][0] = 1; triangle[i][i] = 1; } // 计算其他位置的值 for (i = 2; i \u0026lt; ROWS; i++) { for (j = 1; j \u0026lt; i; j++) { triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j]; } } // 打印杨辉三角 for (i = 0; i \u0026lt; ROWS; i++) { for (j = 0; j \u0026lt;= i; j++) { printf(\u0026#34;%d \u0026#34;, triangle[i][j]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 方法二：使用一个数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;stdio.h\u0026gt; #define ROWS 10 int main() { int triangle[ROWS]; int i, j; // 初始化第一行为1 triangle[0] = 1; // 打印第一行 printf(\u0026#34;%d\\n\u0026#34;, triangle[0]); // 计算并打印其他行 for (i = 1; i \u0026lt; ROWS; i++) { triangle[i] = 1; for (j = i - 1; j \u0026gt; 0; j--) { triangle[j] += triangle[j - 1]; } for (j = 0; j \u0026lt;= i; j++) { printf(\u0026#34;%d \u0026#34;, triangle[j]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 这两种方法都可以生成杨辉三角，你可以根据自己的需求选择使用哪种方法。\n如何利用这两种方法输出金字塔形的杨辉三角 要输出金字塔形的杨辉三角，我们可以在上述两种方法的基础上进行修改，主要是调整打印格式。以下是修改后的代码：\n方法一：使用两个数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;stdio.h\u0026gt; #define ROWS 10 int main() { int triangle[ROWS][ROWS]; int i, j; // 初始化第一列和对角线为1 for (i = 0; i \u0026lt; ROWS; i++) { triangle[i][0] = 1; triangle[i][i] = 1; } // 计算其他位置的值 for (i = 2; i \u0026lt; ROWS; i++) { for (j = 1; j \u0026lt; i; j++) { triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j]; } } // 打印金字塔形杨辉三角 for (i = 0; i \u0026lt; ROWS; i++) { // 打印空格，形成金字塔形状 for (j = 0; j \u0026lt; ROWS - i - 1; j++) { printf(\u0026#34; \u0026#34;); } for (j = 0; j \u0026lt;= i; j++) { printf(\u0026#34;%d \u0026#34;, triangle[i][j]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 方法二：使用一个数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;stdio.h\u0026gt; #define ROWS 10 int main() { int triangle[ROWS]; int i, j; // 初始化第一行为1 triangle[0] = 1; // 打印第一行 printf(\u0026#34; \u0026#34;); // 打印一个空格，使金字塔形状更明显 printf(\u0026#34;%d\\n\u0026#34;, triangle[0]); // 计算并打印其他行 for (i = 1; i \u0026lt; ROWS; i++) { triangle[i] = 1; for (j = i - 1; j \u0026gt; 0; j--) { triangle[j] += triangle[j - 1]; } // 打印空格，形成金字塔形状 for (j = 0; j \u0026lt; ROWS - i - 1; j++) { printf(\u0026#34; \u0026#34;); } for (j = 0; j \u0026lt;= i; j++) { printf(\u0026#34;%d \u0026#34;, triangle[j]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 这两种方法都会输出金字塔形的杨辉三角。方法一是使用二维数组来存储杨辉三角的每一行，而方法二则是使用一维数组来存储当前行的值，并通过计算得到下一行的值。\nC语言中do\u0026hellip;\u0026hellip;while\u0026hellip;\u0026hellip;循环是干什么的 在C语言中，do\u0026hellip;while循环是一种先执行循环体，然后再判断循环条件的循环结构。它的基本语法如下：\n1 2 3 do { // 循环体语句 } while (条件表达式); do\u0026hellip;while循环的执行过程如下：\n执行do后面的循环体语句。 计算while后面的条件表达式。 如果条件表达式的值为真（非零），则返回步骤1继续执行循环体； 如果条件表达式的值为假（零），则循环结束。 与while循环不同的是，do\u0026hellip;while循环的循环体至少会执行一次，即使条件表达式在第一次判断时就为假。这是因为do\u0026hellip;while循环是先执行循环体，然后再判断条件。\n例如，下面的代码使用do\u0026hellip;while循环来计算用户输入的数字之和，直到用户输入负数为止：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; int main() { int num, sum = 0; do { printf(\u0026#34;请输入一个数字（输入负数结束）：\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;num); sum += num; } while (num \u0026gt;= 0); printf(\u0026#34;输入的数字之和为：%d\\n\u0026#34;, sum); return 0; } 在这个例子中，do\u0026hellip;while循环会先执行循环体，要求用户输入一个数字，并将其累加到sum变量中。然后判断num是否小于0，如果不是，则继续执行循环体；如果是，则循环结束。\n打印斐波那契数列的两种方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; int main() { unsigned long long w, u = 1, v = 1, j; scanf(\u0026#34;%12llu\u0026#34;, \u0026amp;j); printf(\u0026#34;%12llu %12llu\u0026#34;, u, v); for(int k = 3; k \u0026lt;= j; k++){ w = v + u; u = v; v = w; printf(\u0026#34; %12llu\u0026#34;,w); } } Another solution:\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdio.h\u0026gt; int main() { int k = 3; do { k++; w = u + v; u = v; v = w; printf(\u0026#34; %12llu\u0026#34;,w); } while (k \u0026lt;= j); } C语言中if循环、while循环和do\u0026hellip;while循环的区别 在C语言中，if语句、while循环和do...while循环是用于控制程序流程的不同结构。它们之间的主要区别在于执行条件判断的时机和循环体执行的次数。\n1. if语句 if语句用于根据一个条件来决定是否执行某个代码块。\n它只执行一次条件判断，如果条件为真，则执行相应的代码块；如果条件为假，则不执行。\n语法：\n1 2 3 if (条件表达式) { 代码块 } 2. while循环 while循环用于在条件为真时重复执行一个代码块。\n它先进行条件判断，如果条件为真，则执行循环体，然后再次进行条件判断，以此类推，直到条件为假时退出循环。\n语法：\n1 2 3 while (条件表达式) { 代码块 } 3. do\u0026hellip;while循环 do...while循环也用于在条件为真时重复执行一个代码块。\n它与while循环的不同之处在于，它先执行一次循环体，然后再进行条件判断。因此，do...while循环的循环体至少会执行一次。\n语法：\n1 2 3 do { 代码块 } while (条件表达式); 区别总结 执行顺序： if语句：先判断条件，再执行代码块（执行0次或1次）。 while循环：先判断条件，再执行代码块（执行0次或多次）。 do...while循环：先执行代码块，再判断条件（执行1次或多次）。 循环体执行次数： if语句：执行0次或1次。 while循环：执行0次或多次。 do...while循环：执行1次或多次。 条件判断时机： if语句和while循环：在循环体执行之前判断条件。 do...while循环：在循环体执行之后判断条件。 根据具体的需求，选择合适的控制结构可以使代码更加清晰和高效。\nC语言中如果我定义了一个数组i[5][6][9][7][10]，那么i[3][5][7]是什么意思，并举个例子\n在C语言中，如果你定义了一个五维数组i[5][6][9][7][10]，那么i[3][5][7]指的是这个五维数组中的一个特定元素。具体来说，它是在第一维上取索引为3，第二维上取索引为5，第三维上取索引为7的元素。\n五维数组可以看作是一个由多个四维数组组成的数组，每个四维数组又由多个三维数组组成，以此类推。因此，i[3][5][7]实际上是访问了这个数组中的一个三维数组。\n为了更清楚地理解，我们可以将这个五维数组想象成一个五层的立方体，每一层都有6x9x7x10个元素。i[3][5][7]就是在这个立方体的第四层（因为索引从0开始），第五行（因为索引从0开始），第八列（因为索引从0开始）的那个元素。\n请注意，C语言中的数组索引是从0开始的，这意味着第一个元素的索引是0，而不是1。因此，i[3][5][7]实际上是访问了这个数组中的第4个、第6个和第8个元素（在各自的维度上）。\nC\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;stdio.h\u0026gt; int main() { // 定义一个五维数组 int i[5][6][9][7][10]; // 初始化数组元素 for (int a = 0; a \u0026lt; 5; a++) { for (int b = 0; b \u0026lt; 6; b++) { for (int c = 0; c \u0026lt; 9; c++) { for (int d = 0; d \u0026lt; 7; d++) { for (int e = 0; e \u0026lt; 10; e++) { i[a][b][c][d][e] = a * 1000 + b * 100 + c * 10 + d * 1 + e; } } } } } // 打印特定元素的值 printf(\u0026#34;The value of i[3][5][7] is: %d\\n\u0026#34;, i[3][5][7]); return 0; } 在这个例子中，我们定义了一个五维数组i，并使用五个嵌套的循环来初始化数组中的每个元素。每个元素的值是通过将其索引值组合而成的。然后，我们打印出i[3][5][7]的值，这是数组中第四层、第五行、第八列的元素的值。\n运行这段代码，你会看到输出结果为：\n1 The value of i[3][5][7] is: 3570 这个结果符合我们的预期，因为i[3][5][7]的值是由索引值3、5、7组合而成的，即3570。\n前置自增（++i）和后置自增（i++）有什么区别？ 运算顺序 前置自增（++i） 先将变量 i 的值加 1，然后再使用 i 的值进行表达式的计算。例如： 1 2 int i = 5; int a = ++i; 在这里，首先 i 的值变为 6，然后将 6 赋值给 a，所以 a 的值为 6，i 的值也为 6。 后置自增（i++） 先使用变量 i 的值进行表达式的计算，然后再将 i 的值加 1。例如： 1 2 int i = 5; int a = i++; 首先将 i 的当前值 5 赋值给 a，然后 i 的值变为 6。所以 a 的值为 5，i 的值为 6。 返回值不同 前置自增（++i） 前置自增表达式的值是自增后变量的值。例如在int a = ++i;中，++i 返回的是 i 自增后的值。 后置自增（i++） 后置自增表达式的值是变量自增前的值。例如在int a = i++;中，i++ 返回的是 i 自增前的值。 在表达式中的应用差异 前置自增（++i） 如果在一个复杂表达式中使用前置自增，变量会先自增，再参与表达式运算。例如： 1 2 int i = 5; int a = (++i) * 2; 首先 i 变为 6，然后 6 * 2 的结果 12 赋值给 a。 后置自增（i++） 在复杂表达式中使用后置自增时，变量先参与表达式运算，然后自增。例如： 1 2 int i = 5; int a = (i++) * 2; 首先 5 * 2 的结果 10 赋值给 a，然后 i 变为 6。 效率方面（在某些情况下） 前置自增（++i） 对于用户自定义类型（如结构体等），前置自增通常更高效。因为前置自增只需要对变量进行一次操作（先自增再返回）。 后置自增（i++） 对于用户自定义类型，后置自增相对效率较低。因为它需要先保存变量的原始值用于返回，然后再对变量进行自增操作，涉及更多的步骤。不过对于基本数据类型，现代编译器通常会进行优化，这种效率差异往往可以忽略不计。 C语言中各种排序 1.直接选择排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;stdio.h\u0026gt; #define m 10 int main() { int i, j, k, r, a[m]; printf(\u0026#34;please input achievement:\\n\u0026#34;); for (i = 0; i \u0026lt; m; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } for (i = 0; i \u0026lt; m - 1; i++) { j = i; for (k = i + 1; k \u0026lt; m; k++) { if (a[k] \u0026lt; a[j]) { j = k; } } r = a[i]; a[i] = a[j]; a[j] = r; } printf(\u0026#34;answer:\\n\u0026#34;); for (i = 0; i \u0026lt; m; i++) { if (i % 10 == 0) { printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;%6d\u0026#34;, a[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } 1.1进阶版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;stdio.h\u0026gt; // 排序函数，采用选择排序的变种 void Sort(int a[], int len) { int min, max, temp, i, j; // 声明必要的变量 // 循环直到中间位置 for (i = 0; i \u0026lt; len / 2; i++) { min = i; // 假设当前最小值的索引为i max = i; // 假设当前最大值的索引为i // 寻找当前未排序部分的最小值和最大值 for (j = i + 1; j \u0026lt;= len - 1 - i; j++) { // 如果找到更小的值，更新min的索引 if (a[j] \u0026lt; a[min]) min = j; // 如果找到更大的值，更新max的索引 else if (a[j] \u0026gt; a[max]) max = j; } // 如果找到的最小值不在当前位置i，交换位置 if (min != i) { temp = a[i]; a[i] = a[min]; a[min] = temp; } // 如果最大值的索引仍为i，则更新为最小值的索引 if (max == i) max = min; // 如果找到的最大值不在当前位置的对称位置，交换位置 if (max != len - 1 - i) { temp = a[len - 1 - i]; a[len - 1 - i] = a[max]; a[max] = temp; } } } int main() { int a[10]; // 定义一个大小为10的数组 // 输入10个整数 for (int i = 0; i \u0026lt; 10; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } int len = sizeof(a) / sizeof(a[0]); // 计算数组的长度 // 调用排序函数进行排序 Sort(a, len); // 输出排序后的数组 for (int i = 0; i \u0026lt; len; i++) { printf(\u0026#34;%d \u0026#34;, a[i]); } printf(\u0026#34;\\n\u0026#34;); // 换行 return 0; // 程序结束返回0 } 2.冒泡排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;stdio.h\u0026gt; void bubblesort(int a[], int len) { for (int i = 0; i \u0026lt; len; i++) { for (int j = 0; j \u0026lt; len - 1; j++) { if (a[j] \u0026gt; a[j + 1]) { int tmp = a[j]; a[j] = a[j + 1]; a[j + 1] = tmp; } } } } int main() { int len, i; scanf(\u0026#34;%d\u0026#34;, \u0026amp;len); int s[len]; for (i = 0; i \u0026lt; len; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;s[i]); } bubblesort(s, len); printf(\u0026#34;answer:\\n\u0026#34;); for (i = 0; i \u0026lt; len; i++) { if (i % 5 == 0 \u0026amp;\u0026amp; i != 0) { printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;%3d\u0026#34;, s[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } or\u0026hellip;\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; void bubblesort(int s[], int len) { int i, r; bool flag; flag = true; while (flag) { flag = false; for (i = 0; i \u0026lt; len - 1; i++) { if (s[i] \u0026gt; s[i + 1]) { r = s[i]; s[i] = s[i + 1]; s[i + 1] = r; flag = true; } } } } int main() { int len, i; scanf(\u0026#34;%d\u0026#34;, \u0026amp;len); int s[len]; for (i = 0; i \u0026lt; len; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;s[i]); } bubblesort(s, len); printf(\u0026#34;answer:\\n\u0026#34;); for (i = 0; i \u0026lt; len; i++) { if (i % 5 == 0 \u0026amp;\u0026amp; i != 0) { printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;%3d\u0026#34;, s[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } 3.直接插入排序 基本步骤：\n首先，将数组中的第一个元素看作是一个初始的有序序列（长度为 1）。 然后，从第二个元素开始（即对于未排序数据），依次取出每个元素。 对于取出的每个未排序元素，在已有的有序序列中从后向前进行扫描比较。 如果该未排序元素小于已排序序列中的当前比较元素，就将已排序序列中的当前比较元素向后移动一位。 持续这个比较和移动的过程，直到找到合适的位置，将未排序元素插入到该位置，使得插入后新的序列依然有序。\n代码: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;stdio.h\u0026gt; void sort(int n, int a[]) { int i, j, k, r; for (i = 1; i \u0026lt; n; i++) { j = i - 1; while ((a[j] \u0026gt; a[i]) \u0026amp;\u0026amp; (j \u0026gt;= 0)) { j = j - 1; } r = a[i]; for (k = i - 1; k \u0026gt;= j + 1; k--) { a[k + 1] = a[k]; } a[j + 1] = r; } } int main() { int len, i; scanf(\u0026#34;%d\u0026#34;, \u0026amp;len); int s[len]; for (i = 0; i \u0026lt; len; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;s[i]); } sort(len, s); printf(\u0026#34;answer:\\n\u0026#34;); for (i = 0; i \u0026lt; len; i++) { if (i % 5 == 0 \u0026amp;\u0026amp; i != 0) { printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;%3d\u0026#34;, s[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } 4.归并排序 基本概念 归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide - and - Conquer）的一个非常典型的应用。\n原理 分治思想 分解：将一个长度为 n 的数组分成两个长度大致为 n/2 的子数组，然后对每个子数组继续分解，直到子数组的长度为 1。 合并：将两个或多个已经有序的子数组合并成一个有序数组。从最小的子数组开始，逐步合并成较大的有序数组，最终得到一个完全有序的数组。 合并过程 假设要合并两个有序子数组 A 和 B（分别记为 A = [a1, a2, …, am] 和 B = [b1, b2, …, bn]），创建一个临时数组 C 来存储合并后的结果。 比较 A 和 B 的第一个元素，将较小的元素放入 C 中。如果 A 的第一个元素较小，就将 a1 放入 C 中，然后考虑 A 中的下一个元素 a2；如果 B 的第一个元素较小，就将 b1 放入 C 中，然后考虑 B 中的下一个元素 b2。 重复这个比较和放入的过程，直到 A 或 B 中的所有元素都被放入 C 中。 如果 A 中还有剩余元素，将它们全部放入 C 中；如果 B 中还有剩余元素，也将它们全部放入 C 中。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include \u0026lt;stdio.h\u0026gt; void merge(int arr[], int tmp[], int left, int mid, int right) { int i, j, t; for (i = left, j = mid + 1, t = left; i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= right; t++) { if (arr[i] \u0026lt;= arr[j]) { tmp[t] = arr[i], i++; } else { tmp[t] = arr[j], j++; } } for (; i \u0026lt;= mid; i++) { tmp[t] = arr[i]; t++; } for (; j \u0026lt;= right; j++) { tmp[t++] = arr[j]; t++; } for (t = left; t \u0026lt;= right; t++) { arr[t] = tmp[t]; } } void msort(int arr[], int tmp[], int left, int right) { int mid; if (left != right) { mid = (left + right) / 2; msort(arr, tmp, left, mid); msort(arr, tmp, mid + 1, right); merge(arr, tmp, left, mid, right); } } void mergesort(int arr[], int len) { int tmp[len]; msort(arr, tmp, 0, len - 1); } int main() { int len, i; scanf(\u0026#34;%d\u0026#34;, \u0026amp;len); int s[len]; for (i = 0; i \u0026lt; len; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;s[i]); } mergesort(s, len); printf(\u0026#34;answer:\\n\u0026#34;); for (i = 0; i \u0026lt; len; i++) { if (i % 5 == 0 \u0026amp;\u0026amp; i != 0) { printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;%3d\u0026#34;, s[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } Q 在C语言中*ptr++和(*ptr)++有区别吗 在 C 语言中，*ptr++和(*ptr)++有区别。\n*ptr++： 这个表达式的作用是先取*ptr的值，然后将指针ptr向后移动一位（指向下一个存储单元）。 例如，如果ptr指向一个整数数组，假设初始时ptr指向数组的第一个元素，执行*ptr++后，会得到第一个元素的值，并且ptr指向数组的第二个元素。 (*ptr)++： 这个表达式是先取指针ptr所指向的内容，然后将这个内容的值加 1。 例如，如果ptr指向一个整数，执行(*ptr)++后，ptr所指向的整数的值会增加 1。 以下是一段 C 语言代码示例，演示*ptr++和(*ptr)++的不同用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; int main() { int arr[] = {10, 20, 30}; int *ptr = arr; // 演示 *ptr++ printf(\u0026#34;*ptr++ 的结果：\\n\u0026#34;); printf(\u0026#34;初始 ptr 指向的值：%d\\n\u0026#34;, *ptr); printf(\u0026#34;执行 *ptr++ 后 ptr 指向的值：%d\\n\u0026#34;, *ptr++); printf(\u0026#34;再次执行 *ptr++ 后 ptr 指向的值：%d\\n\u0026#34;, *ptr++); ptr = arr; // 将 ptr 重新指向数组首地址 // 演示 (*ptr)++ printf(\u0026#34;\\n(*ptr)++ 的结果：\\n\u0026#34;); printf(\u0026#34;初始 ptr 指向的值：%d\\n\u0026#34;, *ptr); printf(\u0026#34;执行 (*ptr)++ 后 ptr 指向的值：%d\\n\u0026#34;, (*ptr)++); printf(\u0026#34;再次执行 (*ptr)++ 后 ptr 指向的值：%d\\n\u0026#34;, (*ptr)++); return 0; } 在这个示例中，首先展示了*ptr++的用法，它先取出ptr指向的值，然后ptr自增指向下一个元素。接着展示了(*ptr)++的用法，它取出ptr指向的值并将该值加 1。\n","date":"2024-11-03T00:00:00Z","permalink":"https://zhao20060708.github.io/p/c-language/","title":"C language"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block 1 \u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-07T00:00:00Z","permalink":"https://zhao20060708.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo theme Stack supports the creation of interactive image galleries using Markdown. It\u0026rsquo;s powered by PhotoSwipe and its syntax was inspired by Typlog.\nTo use this feature, the image must be in the same directory as the Markdown file, as it uses Hugo\u0026rsquo;s page bundle feature to read the dimensions of the image. External images are not supported.\nSyntax 1 ![Image 1](1.jpg) ![Image 2](2.jpg) Result Photo by mymind and Luke Chesser on Unsplash\n","date":"2023-08-26T00:00:00Z","image":"https://zhao20060708.github.io/p/image-gallery/2_hu15576070775610481867.jpg","permalink":"https://zhao20060708.github.io/p/image-gallery/","title":"Image gallery"},{"content":"For more details, check out the documentation.\nBilibili video Tencent video YouTube video Generic video file Your browser doesn't support HTML5 video. Here is a link to the video instead. Gist GitLab Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Photo by Codioful on Unsplash\n","date":"2023-08-25T00:00:00Z","image":"https://zhao20060708.github.io/p/shortcodes/cover_hu17063188895770243625.jpg","permalink":"https://zhao20060708.github.io/p/shortcodes/","title":"Shortcodes"},{"content":"Stack has built-in support for math typesetting using KaTeX.\nIt\u0026rsquo;s not enabled by default side-wide, but you can enable it for individual posts by adding math: true to the front matter. Or you can enable it side-wide by adding math = true to the params.article section in config.toml.\nInline math This is an inline mathematical expression: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n1 $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$ Block math $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ 1 2 3 $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ 1 2 3 $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ ","date":"2023-08-24T00:00:00Z","permalink":"https://zhao20060708.github.io/p/math-typesetting/","title":"Math Typesetting"}]